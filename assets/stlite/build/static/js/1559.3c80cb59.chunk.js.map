{"version":3,"file":"static/js/1559.3c80cb59.chunk.js","mappings":"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","sources":["../../../streamlit/frontend/lib/src/components/elements/Video/Video.tsx"],"sourcesContent":["/**\n * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)\n * Copyright (c) Yuichiro Tachibana (Tsuchiya) (2022-2024)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, { ReactElement, useEffect, useRef, useMemo } from \"react\"\nimport { Video as VideoProto } from \"@streamlit/lib/src/proto\"\nimport { StreamlitEndpoints } from \"@streamlit/lib/src/StreamlitEndpoints\"\nimport { IS_DEV_ENV } from \"@streamlit/lib/src/baseconsts\"\nimport { WidgetStateManager as ElementStateManager } from \"@streamlit/lib/src/WidgetStateManager\"\nimport { useStliteMediaObjectUrl, useStliteMediaObjects } from \"@stlite/kernel\"\n\nconst DEFAULT_HEIGHT = 528\n\nexport interface VideoProps {\n  endpoints: StreamlitEndpoints\n  width: number\n  element: VideoProto\n  elementMgr: ElementStateManager\n}\n\nexport interface Subtitle {\n  label: string\n  url: string\n}\n\nexport default function Video({\n  element,\n  width,\n  endpoints,\n  elementMgr,\n}: VideoProps): ReactElement {\n  const videoRef = useRef<HTMLVideoElement>(null)\n\n  /* Element may contain \"url\" or \"data\" property. */\n  const {\n    type,\n    url: rawUrl,\n    startTime,\n    subtitles: rawSubtitles,\n    endTime,\n    loop,\n    autoplay,\n    muted,\n  } = element\n  const url = useStliteMediaObjectUrl(rawUrl)\n  const subtitles = useStliteMediaObjects(rawSubtitles)\n\n  const preventAutoplay = useMemo<boolean>(() => {\n    if (!element.id) {\n      // Elements without an ID should never autoplay\n      return true\n    }\n\n    // Recover the state in case this component got unmounted\n    // and mounted again for the same element.\n    const preventAutoplay = elementMgr.getElementState(\n      element.id,\n      \"preventAutoplay\"\n    )\n\n    if (!preventAutoplay) {\n      // Set the state to prevent autoplay in case there is an unmount + mount\n      // for the same element.\n      elementMgr.setElementState(element.id, \"preventAutoplay\", true)\n    }\n    return preventAutoplay ?? false\n  }, [element.id, elementMgr])\n\n  // Handle startTime changes\n  useEffect(() => {\n    if (videoRef.current) {\n      videoRef.current.currentTime = startTime\n    }\n  }, [startTime])\n\n  useEffect(() => {\n    const videoNode = videoRef.current\n\n    const setStartTime: () => void = () => {\n      if (videoNode) {\n        videoNode.currentTime = element.startTime\n      }\n    }\n\n    if (videoNode) {\n      videoNode.addEventListener(\"loadedmetadata\", setStartTime)\n    }\n\n    return () => {\n      if (videoNode) {\n        videoNode.removeEventListener(\"loadedmetadata\", setStartTime)\n      }\n    }\n  }, [element])\n\n  // Stop the video at 'endTime' and handle loop\n  useEffect(() => {\n    const videoNode = videoRef.current\n    if (!videoNode) return\n\n    // Flag to avoid calling 'videoNode.pause()' multiple times\n    let stoppedByEndTime = false\n\n    const handleTimeUpdate = (): void => {\n      if (endTime > 0 && videoNode.currentTime >= endTime) {\n        if (loop) {\n          // If loop is true and we reached 'endTime', reset to 'startTime'\n          videoNode.currentTime = startTime || 0\n          videoNode.play()\n        } else if (!stoppedByEndTime) {\n          stoppedByEndTime = true\n          videoNode.pause()\n        }\n      }\n    }\n\n    if (endTime > 0) {\n      videoNode.addEventListener(\"timeupdate\", handleTimeUpdate)\n    }\n\n    return () => {\n      if (videoNode && endTime > 0) {\n        videoNode.removeEventListener(\"timeupdate\", handleTimeUpdate)\n      }\n    }\n  }, [endTime, loop, startTime])\n\n  // Handle looping the video\n  useEffect(() => {\n    const videoNode = videoRef.current\n    if (!videoNode) return\n\n    // Loop the video when it has ended\n    const handleVideoEnd = (): void => {\n      if (loop) {\n        videoNode.currentTime = startTime || 0 // Reset to startTime or to the start if not specified\n        videoNode.play()\n      }\n    }\n\n    videoNode.addEventListener(\"ended\", handleVideoEnd)\n\n    return () => {\n      if (videoNode) {\n        videoNode.removeEventListener(\"ended\", handleVideoEnd)\n      }\n    }\n  }, [loop, startTime])\n\n  const getYoutubeSrc = (url: string): string => {\n    const { startTime, endTime, loop, autoplay, muted } = element\n    const youtubeUrl = new URL(url)\n\n    if (startTime && !isNaN(startTime)) {\n      youtubeUrl.searchParams.append(\"start\", startTime.toString())\n    }\n\n    if (endTime && !isNaN(endTime)) {\n      youtubeUrl.searchParams.append(\"end\", endTime.toString())\n    }\n\n    if (loop) {\n      youtubeUrl.searchParams.append(\"loop\", \"1\")\n      // When using the loop parameter, YouTube requires the playlist parameter to be set to the same video ID\n      const videoId = youtubeUrl.pathname.split(\"/\").pop()\n\n      if (videoId) {\n        youtubeUrl.searchParams.append(\"playlist\", videoId)\n      }\n    }\n\n    if (autoplay) {\n      youtubeUrl.searchParams.append(\"autoplay\", \"1\")\n    }\n\n    if (muted) {\n      youtubeUrl.searchParams.append(\"mute\", \"1\")\n    }\n\n    return youtubeUrl.toString()\n  }\n\n  /* Is this a YouTube link? If so we need a fancier tag.\n       NOTE: This part assumes the URL is already an \"embed\" link.\n    */\n  if (type === VideoProto.Type.YOUTUBE_IFRAME) {\n    // At some point the width 0 will be passed to this component\n    // which is caused by the AutoSizer of the VerticalLayout\n    // Width 0 will result in height being 0, which results in issue\n    // https://github.com/streamlit/streamlit/issues/5069\n    // To avoid this, when we detect width is 0, we set height to 528,\n    // which is default height based on the default streamlit width\n    const height = width !== 0 ? width * 0.75 : DEFAULT_HEIGHT\n\n    return (\n      <iframe\n        data-testid=\"stVideo\"\n        title={url}\n        src={getYoutubeSrc(url)}\n        width={width}\n        height={height}\n        style={{ colorScheme: \"normal\" }}\n        frameBorder=\"0\"\n        allow=\"autoplay; encrypted-media\"\n        allowFullScreen\n      />\n    )\n  }\n\n  // Only in dev mode we set crossOrigin to \"anonymous\" to avoid CORS issues\n  // when streamlit frontend and backend are running on different ports\n  return (\n    <video\n      data-testid=\"stVideo\"\n      ref={videoRef}\n      controls\n      muted={muted}\n      autoPlay={autoplay && !preventAutoplay}\n      src={endpoints.buildMediaURL(url)}\n      className=\"stVideo\"\n      style={{ width, height: width === 0 ? DEFAULT_HEIGHT : undefined }}\n      crossOrigin={\n        IS_DEV_ENV && subtitles.length > 0 ? \"anonymous\" : undefined\n      }\n    >\n      {subtitles &&\n        subtitles.map((subtitle: Subtitle, idx: number) => (\n          <track\n            key={idx}\n            kind=\"captions\"\n            src={endpoints.buildMediaURL(subtitle.url)}\n            label={subtitle.label}\n            default={idx === 0}\n          />\n        ))}\n    </video>\n  )\n}\n"],"names":["DEFAULT_HEIGHT","Video","_ref","element","width","endpoints","elementMgr","videoRef","useRef","type","url","rawUrl","startTime","subtitles","rawSubtitles","endTime","loop","autoplay","muted","useStliteMediaObjectUrl","useStliteMediaObjects","preventAutoplay","useMemo","id","getElementState","setElementState","useEffect","current","currentTime","videoNode","setStartTime","addEventListener","removeEventListener","stoppedByEndTime","handleTimeUpdate","play","pause","handleVideoEnd","getYoutubeSrc","youtubeUrl","URL","isNaN","searchParams","append","toString","videoId","pathname","split","pop","VideoProto","height","_jsx","title","src","style","colorScheme","frameBorder","allow","allowFullScreen","ref","controls","autoPlay","buildMediaURL","className","undefined","crossOrigin","IS_DEV_ENV","length","children","map","subtitle","idx","kind","label","default"],"sourceRoot":""}