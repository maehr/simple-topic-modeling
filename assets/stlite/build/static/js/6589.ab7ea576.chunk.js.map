{"version":3,"file":"static/js/6589.ab7ea576.chunk.js","mappings":"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","sources":["../../../node_modules/parquet-wasm/bundler/arrow2.js","../../../node_modules/parquet-wasm/bundler/arrow2_bg.js"],"sourcesContent":["import * as wasm from \"./arrow2_bg.wasm\";\nimport { __wbg_set_wasm } from \"./arrow2_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./arrow2_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_32(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcfbc7aedab76e67e(arg0, arg1, addHeapObject(arg2));\n}\n\nlet cachedBigInt64Memory0 = null;\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nlet cachedBigUint64Memory0 = null;\n\nfunction getBigUint64Memory0() {\n    if (cachedBigUint64Memory0 === null || cachedBigUint64Memory0.byteLength === 0) {\n        cachedBigUint64Memory0 = new BigUint64Array(wasm.memory.buffer);\n    }\n    return cachedBigUint64Memory0;\n}\n\nfunction getArrayU64FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getBigUint64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* Read a Parquet file into Arrow data using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* Example:\n*\n* ```js\n* import { tableFromIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readParquet } from \"parquet-wasm/node2\";\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const arrowUint8Array = readParquet(parquetUint8Array);\n* const arrowTable = tableFromIPC(arrowUint8Array);\n* ```\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @returns Uint8Array containing Arrow data in [IPC Stream format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format). To parse this into an Arrow table, pass to `tableFromIPC` in the Arrow JS bindings.\n* @param {Uint8Array} parquet_file\n* @returns {Uint8Array}\n*/\nexport function readParquet(parquet_file) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.readParquet(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Read a Parquet file into Arrow FFI structs using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* This API is less well tested than the \"normal\" `readParquet` API, but should be faster and have\n* **much** less memory overhead (by a factor of 2). If you hit any bugs, please create a\n* reproducible issue at <https://github.com/kylebarron/parquet-wasm/issues/new>.\n*\n* ## Background\n*\n* Under the hood, `parquet-wasm` first decodes a Parquet file into Arrow _in WebAssembly memory_.\n* But then that WebAssembly memory needs to be copied into JavaScript for use by Arrow JS. The\n* \"normal\" read APIs (e.g. `readParquet`) use the [Arrow IPC\n* format](https://arrow.apache.org/docs/python/ipc.html) to get the data back to JavaScript. But\n* this requires another memory copy _inside WebAssembly_ to assemble the various arrays into a\n* single buffer to be copied back to JS.\n*\n* Instead, this API uses Arrow's [C Data\n* Interface](https://arrow.apache.org/docs/format/CDataInterface.html) to be able to copy or view\n* Arrow arrays from within WebAssembly memory without any serialization.\n*\n* I wrote an [interactive blog\n* post](https://observablehq.com/@kylebarron/zero-copy-apache-arrow-with-webassembly) on this\n* approach and the Arrow C Data Interface if you want to read more!\n*\n* ## Caveats\n*\n* This requires you to use [`arrow-js-ffi`](https://github.com/kylebarron/arrow-js-ffi) to parse\n* the Arrow C Data Interface definitions. This library has not yet been tested in production, so\n* it may have bugs!\n*\n* ## Example:\n*\n* ```js\n* import { Table } from \"apache-arrow\";\n* import { parseRecordBatch } from \"arrow-js-ffi\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readParquetFFI, __wasm } from \"parquet-wasm/node2\";\n*\n* // A reference to the WebAssembly memory object. The way to access this is different for each\n* // environment. In Node, use the __wasm export as shown below. In ESM the memory object will\n* // be found on the returned default export.\n* const WASM_MEMORY = __wasm.memory;\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const wasmArrowTable = readParquetFFI(parquetUint8Array);\n*\n* const recordBatches = [];\n* for (let i = 0; i < wasmArrowTable.numBatches(); i++) {\n*   // Note: Unless you know what you're doing, setting `true` below is recommended to _copy_\n*   // table data from WebAssembly into JavaScript memory. This may become the default in the\n*   // future.\n*   const recordBatch = parseRecordBatch(\n*     WASM_MEMORY.buffer,\n*     wasmArrowTable.arrayAddr(i),\n*     wasmArrowTable.schemaAddr(),\n*     true\n*   );\n*   batches.push(recordBatch);\n* }\n*\n* const table = new Table(batches);\n* ```\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @returns an {@linkcode FFIArrowTable} object containing the parsed Arrow table in WebAssembly memory. To read into an Arrow JS table, you'll need to use the Arrow C Data interface.\n* @param {Uint8Array} parquet_file\n* @returns {FFIArrowTable}\n*/\nexport function readParquetFFI(parquet_file) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.readParquetFFI(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return FFIArrowTable.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Read metadata from a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* Example:\n*\n* ```js\n* // Edit the `parquet-wasm` import as necessary\n* import { readMetadata } from \"parquet-wasm/node2\";\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const parquetFileMetaData = readMetadata(parquetUint8Array);\n* ```\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @returns a {@linkcode FileMetaData} object containing metadata of the Parquet file.\n* @param {Uint8Array} parquet_file\n* @returns {FileMetaData}\n*/\nexport function readMetadata(parquet_file) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.readMetadata(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return FileMetaData.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* Read a single row group from a Parquet file into Arrow data using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* Example:\n*\n* ```js\n* import { tableFromIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readRowGroup, readMetadata } from \"parquet-wasm/node2\";\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const parquetFileMetaData = readMetadata(parquetUint8Array);\n*\n* // Read only the first row group\n* const arrowIpcBuffer = wasm.readRowGroup(parquetUint8Array, parquetFileMetaData, 0);\n* const arrowTable = tableFromIPC(arrowUint8Array);\n* ```\n*\n* Note that you can get the number of row groups in a Parquet file using {@linkcode FileMetaData.numRowGroups}\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @param meta {@linkcode FileMetaData} from a call to {@linkcode readMetadata}\n* @param i Number index of the row group to parse\n* @returns Uint8Array containing Arrow data in [IPC Stream format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format). To parse this into an Arrow table, pass to `tableFromIPC` in the Arrow JS bindings.\n* @param {Uint8Array} parquet_file\n* @param {ArrowSchema} schema\n* @param {RowGroupMetaData} meta\n* @returns {Uint8Array}\n*/\nexport function readRowGroup(parquet_file, schema, meta) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(schema, ArrowSchema);\n        _assertClass(meta, RowGroupMetaData);\n        wasm.readRowGroup(retptr, ptr0, len0, schema.__wbg_ptr, meta.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Asynchronously read metadata from a Parquet file using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* For now, this requires knowing the content length of the file, but hopefully this will be\n* relaxed in the future.\n*\n* Example:\n*\n* ```js\n* // Edit the `parquet-wasm` import as necessary\n* import { readMetadataAsync } from \"parquet-wasm\";\n*\n* const parquetFileMetaData = await readMetadataAsync(url);\n* ```\n*\n* @param url String location of remote Parquet file containing Parquet data\n* @param content_length Number content length of file in bytes\n* @returns a {@linkcode FileMetaData} object containing metadata of the Parquet file.\n* @param {string} url\n* @param {number | undefined} content_length\n* @returns {Promise<FileMetaData>}\n*/\nexport function readMetadataAsync(url, content_length) {\n    const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.readMetadataAsync(ptr0, len0, !isLikeNone(content_length), isLikeNone(content_length) ? 0 : content_length);\n    return takeObject(ret);\n}\n\n/**\n* Asynchronously read a single row group from a Parquet file into Arrow data using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* Example:\n*\n* ```js\n* import { tableFromIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readRowGroupAsync, readMetadataAsync } from \"parquet-wasm\";\n*\n* const url = \"https://example.com/file.parquet\";\n* const headResp = await fetch(url, {method: 'HEAD'});\n* const length = parseInt(headResp.headers.get('Content-Length'));\n*\n* const parquetFileMetaData = await readMetadataAsync(url, length);\n*\n* // Read all batches from the file in parallel\n* const promises = [];\n* for (let i = 0; i < parquetFileMetaData.numRowGroups(); i++) {\n*   // IMPORTANT: For now, calling `copy()` on the metadata object is required whenever passing in to\n*   // a function. Hopefully this can be resolved in the future sometime\n*   const rowGroupPromise = wasm.readRowGroupAsync(url, metadata.copy().rowGroup(i));\n*   promises.push(rowGroupPromise);\n* }\n*\n* const recordBatchChunks = await Promise.all(promises);\n* const table = new arrow.Table(recordBatchChunks);\n* ```\n*\n* Note that you can get the number of row groups in a Parquet file using {@linkcode FileMetaData.numRowGroups}\n*\n* @param url String location of remote Parquet file containing Parquet data\n* @param content_length Number content length of file in bytes\n* @param meta {@linkcode FileMetaData} from a call to {@linkcode readMetadata}\n* @param i Number index of the row group to load\n* @returns Uint8Array containing Arrow data in [IPC Stream format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format). To parse this into an Arrow table, pass to `tableFromIPC` in the Arrow JS bindings.\n* @param {string} url\n* @param {RowGroupMetaData} row_group_meta\n* @param {ArrowSchema} arrow_schema\n* @returns {Promise<Uint8Array>}\n*/\nexport function readRowGroupAsync(url, row_group_meta, arrow_schema) {\n    const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertClass(row_group_meta, RowGroupMetaData);\n    _assertClass(arrow_schema, ArrowSchema);\n    const ret = wasm.readRowGroupAsync(ptr0, len0, row_group_meta.__wbg_ptr, arrow_schema.__wbg_ptr);\n    return takeObject(ret);\n}\n\n/**\n* Write Arrow data to a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* For example, to create a Parquet file with Snappy compression:\n*\n* ```js\n* import { tableToIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { WriterPropertiesBuilder, Compression, writeParquet } from \"parquet-wasm/node2\";\n*\n* // Given an existing arrow table under `table`\n* const arrowUint8Array = tableToIPC(table, \"file\");\n* const writerProperties = new WriterPropertiesBuilder()\n*   .setCompression(Compression.SNAPPY)\n*   .build();\n* const parquetUint8Array = writeParquet(arrowUint8Array, writerProperties);\n* ```\n*\n* If `writerProperties` is not provided or is `null`, the default writer properties will be used.\n* This is equivalent to `new WriterPropertiesBuilder().build()`.\n*\n* @param arrow_file Uint8Array containing Arrow data in [IPC **File** format](https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format). If you have an Arrow table in JS, call `tableToIPC(table, \"file\")` in the JS bindings and pass the result here.\n* @param writer_properties Configuration for writing to Parquet. Use the {@linkcode WriterPropertiesBuilder} to build a writing configuration, then call `.build()` to create an immutable writer properties to pass in here.\n* @returns Uint8Array containing written Parquet data.\n* @param {Uint8Array} arrow_file\n* @param {WriterProperties | undefined} writer_properties\n* @returns {Uint8Array}\n*/\nexport function writeParquet(arrow_file, writer_properties) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(arrow_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        let ptr1 = 0;\n        if (!isLikeNone(writer_properties)) {\n            _assertClass(writer_properties, WriterProperties);\n            ptr1 = writer_properties.__destroy_into_raw();\n        }\n        wasm.writeParquet(retptr, ptr0, len0, ptr1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v3 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Write Arrow data to a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* For example, to create a Parquet file with Snappy compression:\n*\n* ```js\n* import { tableToIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { WriterPropertiesBuilder, Compression, _writeParquetFFI } from \"parquet-wasm/node2\";\n*\n* // Given an existing arrow table under `table`\n* const arrowUint8Array = tableToIPC(table, \"file\");\n* const writerProperties = new WriterPropertiesBuilder()\n*   .setCompression(Compression.SNAPPY)\n*   .build();\n* const parquetUint8Array = writeParquet(arrowUint8Array, writerProperties);\n* ```\n*\n* If `writerProperties` is not provided or is `null`, the default writer properties will be used.\n* This is equivalent to `new WriterPropertiesBuilder().build()`.\n*\n* @param arrow_table {@linkcode FFIArrowTable} Arrow Table in Wasm memory\n* @param writer_properties Configuration for writing to Parquet. Use the {@linkcode WriterPropertiesBuilder} to build a writing configuration, then call `.build()` to create an immutable writer properties to pass in here.\n* @returns Uint8Array containing written Parquet data.\n* @param {FFIArrowTable} arrow_table\n* @param {WriterProperties | undefined} writer_properties\n* @returns {Uint8Array}\n*/\nexport function _writeParquetFFI(arrow_table, writer_properties) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(arrow_table, FFIArrowTable);\n        var ptr0 = arrow_table.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(writer_properties)) {\n            _assertClass(writer_properties, WriterProperties);\n            ptr1 = writer_properties.__destroy_into_raw();\n        }\n        wasm._writeParquetFFI(retptr, ptr0, ptr1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v3 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_165(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h75211a0883f244f7(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* Supported compression algorithms.\n*\n* Codecs added in format version X.Y can be read by readers based on X.Y and later.\n* Codec support may vary between readers based on the format version and\n* libraries available at runtime.\n*/\nexport const Compression = Object.freeze({ UNCOMPRESSED:0,\"0\":\"UNCOMPRESSED\",SNAPPY:1,\"1\":\"SNAPPY\",GZIP:2,\"2\":\"GZIP\",BROTLI:3,\"3\":\"BROTLI\",\n/**\n* @deprecated as of Parquet 2.9.0.\n* Switch to LZ4_RAW\n*/\nLZ4:4,\"4\":\"LZ4\",ZSTD:5,\"5\":\"ZSTD\",LZ4_RAW:6,\"6\":\"LZ4_RAW\", });\n/**\n* Encodings supported by Parquet.\n* Not all encodings are valid for all types. These enums are also used to specify the\n* encoding of definition and repetition levels.\n*/\nexport const Encoding = Object.freeze({\n/**\n* Default byte encoding.\n* - BOOLEAN - 1 bit per value, 0 is false; 1 is true.\n* - INT32 - 4 bytes per value, stored as little-endian.\n* - INT64 - 8 bytes per value, stored as little-endian.\n* - FLOAT - 4 bytes per value, stored as little-endian.\n* - DOUBLE - 8 bytes per value, stored as little-endian.\n* - BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.\n* - FIXED_LEN_BYTE_ARRAY - just the bytes are stored.\n*/\nPLAIN:0,\"0\":\"PLAIN\",\n/**\n* **Deprecated** dictionary encoding.\n*\n* The values in the dictionary are encoded using PLAIN encoding.\n* Since it is deprecated, RLE_DICTIONARY encoding is used for a data page, and\n* PLAIN encoding is used for dictionary page.\n*/\nPLAIN_DICTIONARY:1,\"1\":\"PLAIN_DICTIONARY\",\n/**\n* Group packed run length encoding.\n*\n* Usable for definition/repetition levels encoding and boolean values.\n*/\nRLE:2,\"2\":\"RLE\",\n/**\n* Bit packed encoding.\n*\n* This can only be used if the data has a known max width.\n* Usable for definition/repetition levels encoding.\n*/\nBIT_PACKED:3,\"3\":\"BIT_PACKED\",\n/**\n* Delta encoding for integers, either INT32 or INT64.\n*\n* Works best on sorted data.\n*/\nDELTA_BINARY_PACKED:4,\"4\":\"DELTA_BINARY_PACKED\",\n/**\n* Encoding for byte arrays to separate the length values and the data.\n*\n* The lengths are encoded using DELTA_BINARY_PACKED encoding.\n*/\nDELTA_LENGTH_BYTE_ARRAY:5,\"5\":\"DELTA_LENGTH_BYTE_ARRAY\",\n/**\n* Incremental encoding for byte arrays.\n*\n* Prefix lengths are encoded using DELTA_BINARY_PACKED encoding.\n* Suffixes are stored using DELTA_LENGTH_BYTE_ARRAY encoding.\n*/\nDELTA_BYTE_ARRAY:6,\"6\":\"DELTA_BYTE_ARRAY\",\n/**\n* Dictionary encoding.\n*\n* The ids are encoded using the RLE encoding.\n*/\nRLE_DICTIONARY:7,\"7\":\"RLE_DICTIONARY\",\n/**\n* Encoding for floating-point data.\n*\n* K byte-streams are created where K is the size in bytes of the data type.\n* The individual bytes of an FP value are scattered to the corresponding stream and\n* the streams are concatenated.\n* This itself does not reduce the size of the data but can lead to better compression\n* afterwards.\n*/\nBYTE_STREAM_SPLIT:8,\"8\":\"BYTE_STREAM_SPLIT\", });\n/**\n* The Parquet version to use when writing\n*/\nexport const WriterVersion = Object.freeze({ V1:0,\"0\":\"V1\",V2:1,\"1\":\"V2\", });\n/**\n* Arrow Schema representing a Parquet file.\n*/\nexport class ArrowSchema {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ArrowSchema.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_arrowschema_free(ptr);\n    }\n    /**\n    * Clone this struct in wasm memory.\n    * @returns {ArrowSchema}\n    */\n    copy() {\n        const ret = wasm.arrowschema_copy(this.__wbg_ptr);\n        return ArrowSchema.__wrap(ret);\n    }\n}\n/**\n* Metadata for a column chunk.\n*/\nexport class ColumnChunkMetaData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ColumnChunkMetaData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_columnchunkmetadata_free(ptr);\n    }\n    /**\n    * File where the column chunk is stored.\n    *\n    * If not set, assumed to belong to the same file as the metadata.\n    * This path is relative to the current file.\n    * @returns {string | undefined}\n    */\n    filePath() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_filePath(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Byte offset in `file_path()`.\n    * @returns {bigint}\n    */\n    fileOffset() {\n        const ret = wasm.columnchunkmetadata_fileOffset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {string}\n    */\n    pathInSchema() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_pathInSchema(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {boolean}\n    */\n    statistics_exist() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_statistics_exist(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getStatisticsMinValue() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_getStatisticsMinValue(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getStatisticsMaxValue() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_getStatisticsMaxValue(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getStatisticsNullCount() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_getStatisticsNullCount(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Total number of values in this column chunk. Note that this is not necessarily the number\n    * of rows. E.g. the (nested) array `[[1, 2], [3]]` has 2 rows and 3 values.\n    * @returns {bigint}\n    */\n    numValues() {\n        const ret = wasm.columnchunkmetadata_numValues(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns the total compressed data size of this column chunk.\n    * @returns {bigint}\n    */\n    compressedSize() {\n        const ret = wasm.columnchunkmetadata_compressedSize(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns the total uncompressed data size of this column chunk.\n    * @returns {bigint}\n    */\n    uncompressedSize() {\n        const ret = wasm.columnchunkmetadata_uncompressedSize(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns the offset for the column data.\n    * @returns {bigint}\n    */\n    dataPageOffset() {\n        const ret = wasm.columnchunkmetadata_dataPageOffset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns `true` if this column chunk contains a index page, `false` otherwise.\n    * @returns {boolean}\n    */\n    hasIndexPage() {\n        const ret = wasm.columnchunkmetadata_hasIndexPage(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Returns the offset for the index page.\n    * @returns {bigint | undefined}\n    */\n    indexPageOffset() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_indexPageOffset(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getBigInt64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the offset for the dictionary page, if any.\n    * @returns {bigint | undefined}\n    */\n    dictionaryPageOffset() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_dictionaryPageOffset(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getBigInt64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the number of encodings for this column\n    * @returns {number}\n    */\n    numColumnEncodings() {\n        const ret = wasm.columnchunkmetadata_numColumnEncodings(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the offset and length in bytes of the column chunk within the file\n    * @returns {BigUint64Array}\n    */\n    byteRange() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_byteRange(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU64FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 8);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Wrapper around an ArrowArray FFI struct in Wasm memory.\n*/\nexport class FFIArrowArray {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowarray_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    addr() {\n        const ret = wasm.ffiarrowarray_addr(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    */\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowarray_free(ptr);\n    }\n    /**\n    */\n    drop() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowarray_free(ptr);\n    }\n}\n/**\n* Wrapper to represent an Arrow Chunk in Wasm memory, e.g. a  collection of FFI ArrowArray\n* structs\n*/\nexport class FFIArrowChunk {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowchunk_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    length() {\n        const ret = wasm.ffiarrowchunk_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    addr(i) {\n        const ret = wasm.ffiarrowchunk_addr(this.__wbg_ptr, i);\n        return ret;\n    }\n}\n/**\n* Wrapper around an ArrowSchema FFI struct in Wasm memory.\n*/\nexport class FFIArrowField {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowfield_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    addr() {\n        const ret = wasm.ffiarrowarray_addr(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n* Wrapper an Arrow RecordBatch stored as FFI in Wasm memory.\n*\n* Refer to {@linkcode readParquetFFI} for instructions on how to use this.\n*/\nexport class FFIArrowRecordBatch {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowrecordbatch_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    array_addr() {\n        const ret = wasm.ffiarrowrecordbatch_array_addr(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    field_addr() {\n        const ret = wasm.ffiarrowarray_addr(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n* Wrapper around a collection of FFI ArrowSchema structs in Wasm memory\n*/\nexport class FFIArrowSchema {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowschema_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    length() {\n        const ret = wasm.ffiarrowchunk_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    addr(i) {\n        const ret = wasm.ffiarrowschema_addr(this.__wbg_ptr, i);\n        return ret;\n    }\n}\n/**\n* Wrapper around an Arrow Table in Wasm memory (a list of FFIArrowRecordBatch objects.)\n*\n* Refer to {@linkcode readParquetFFI} for instructions on how to use this.\n*/\nexport class FFIArrowTable {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FFIArrowTable.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowtable_free(ptr);\n    }\n    /**\n    * Get the total number of record batches in the table\n    * @returns {number}\n    */\n    numBatches() {\n        const ret = wasm.ffiarrowchunk_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the pointer to one ArrowSchema FFI struct\n    * @returns {number}\n    */\n    schemaAddr() {\n        const ret = wasm.ffiarrowtable_schemaAddr(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the pointer to one ArrowArray FFI struct for a given chunk index and column index\n    * @param chunk number The chunk index to use\n    * @returns number pointer to an ArrowArray FFI struct in Wasm memory\n    * @param {number} chunk\n    * @returns {number}\n    */\n    arrayAddr(chunk) {\n        const ret = wasm.ffiarrowtable_arrayAddr(this.__wbg_ptr, chunk);\n        return ret;\n    }\n    /**\n    */\n    drop() {\n        const ptr = this.__destroy_into_raw();\n        wasm.ffiarrowtable_drop(ptr);\n    }\n}\n/**\n* Metadata for a Parquet file.\n*/\nexport class FileMetaData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FileMetaData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_filemetadata_free(ptr);\n    }\n    /**\n    * Clone this struct in wasm memory.\n    * @returns {FileMetaData}\n    */\n    copy() {\n        const ret = wasm.filemetadata_copy(this.__wbg_ptr);\n        return FileMetaData.__wrap(ret);\n    }\n    /**\n    * Version of this file.\n    * @returns {number}\n    */\n    version() {\n        const ret = wasm.filemetadata_version(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * number of rows in the file.\n    * @returns {number}\n    */\n    numRows() {\n        const ret = wasm.filemetadata_numRows(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * String message for application that wrote this file.\n    * @returns {string | undefined}\n    */\n    createdBy() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.filemetadata_createdBy(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Number of row groups in the file\n    * @returns {number}\n    */\n    numRowGroups() {\n        const ret = wasm.filemetadata_numRowGroups(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a single RowGroupMetaData by index\n    * @param {number} i\n    * @returns {RowGroupMetaData}\n    */\n    rowGroup(i) {\n        const ret = wasm.filemetadata_rowGroup(this.__wbg_ptr, i);\n        return RowGroupMetaData.__wrap(ret);\n    }\n    /**\n    * @returns {SchemaDescriptor}\n    */\n    schema() {\n        const ret = wasm.filemetadata_schema(this.__wbg_ptr);\n        return SchemaDescriptor.__wrap(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    keyValueMetadata() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.filemetadata_keyValueMetadata(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ArrowSchema}\n    */\n    arrowSchema() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.filemetadata_arrowSchema(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ArrowSchema.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Metadata for a row group.\n*/\nexport class RowGroupMetaData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RowGroupMetaData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rowgroupmetadata_free(ptr);\n    }\n    /**\n    * Number of rows in this row group.\n    * @returns {number}\n    */\n    numRows() {\n        const ret = wasm.rowgroupmetadata_numRows(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Number of columns in this row group.\n    * @returns {number}\n    */\n    numColumns() {\n        const ret = wasm.rowgroupmetadata_numColumns(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a single column chunk metadata by index\n    * @param {number} i\n    * @returns {ColumnChunkMetaData}\n    */\n    column(i) {\n        const ret = wasm.rowgroupmetadata_column(this.__wbg_ptr, i);\n        return ColumnChunkMetaData.__wrap(ret);\n    }\n    /**\n    * Total byte size of all uncompressed column data in this row group.\n    * @returns {number}\n    */\n    totalByteSize() {\n        const ret = wasm.rowgroupmetadata_totalByteSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Total size of all compressed column data in this row group.\n    * @returns {number}\n    */\n    compressedSize() {\n        const ret = wasm.rowgroupmetadata_compressedSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n* A schema descriptor. This encapsulates the top-level schemas for all the columns,\n* as well as all descriptors for all the primitive columns.\n*/\nexport class SchemaDescriptor {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SchemaDescriptor.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_schemadescriptor_free(ptr);\n    }\n    /**\n    * The schemas' name.\n    * @returns {string}\n    */\n    name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.schemadescriptor_name(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * The number of columns in the schema\n    * @returns {number}\n    */\n    numColumns() {\n        const ret = wasm.schemadescriptor_numColumns(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * The number of fields in the schema\n    * @returns {number}\n    */\n    numFields() {\n        const ret = wasm.schemadescriptor_numFields(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n* Immutable struct to hold writing configuration for `writeParquet2`.\n*\n* Use {@linkcode WriterPropertiesBuilder} to create a configuration, then call {@linkcode\n* WriterPropertiesBuilder.build} to create an instance of `WriterProperties`.\n*/\nexport class WriterProperties {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WriterProperties.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_writerproperties_free(ptr);\n    }\n}\n/**\n* Builder to create a writing configuration for `writeParquet2`\n*\n* Call {@linkcode build} on the finished builder to create an immputable {@linkcode WriterProperties} to pass to `writeParquet2`\n*/\nexport class WriterPropertiesBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WriterPropertiesBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_writerpropertiesbuilder_free(ptr);\n    }\n    /**\n    * Returns default state of the builder.\n    */\n    constructor() {\n        const ret = wasm.writerpropertiesbuilder_new();\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Finalizes the configuration and returns immutable writer properties struct.\n    * @returns {WriterProperties}\n    */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_build(ptr);\n        return WriterProperties.__wrap(ret);\n    }\n    /**\n    * Sets writer version.\n    * @param {number} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setWriterVersion(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setWriterVersion(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Sets encoding for any column.\n    *\n    * If dictionary is not enabled, this is treated as a primary encoding for all\n    * columns. In case when dictionary is enabled for any column, this value is\n    * considered to be a fallback encoding for that column.\n    *\n    * Panics if user tries to set dictionary encoding here, regardless of dictionary\n    * encoding flag being set.\n    * @param {number} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setEncoding(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setEncoding(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Sets compression codec for any column.\n    * @param {number} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setCompression(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setCompression(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Sets flag to enable/disable statistics for any column.\n    * @param {boolean} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setStatisticsEnabled(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setStatisticsEnabled(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_error_new(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_filemetadata_new(arg0) {\n    const ret = FileMetaData.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_bigint_from_i64(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_fetch_57429b87be3dcc33(arg0) {\n    const ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_841ac57cff3d672b(arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n};\n\nexport function __wbg_String_88810dfeb4021902(arg0, arg1) {\n    const ret = String(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbindgen_cb_drop(arg0) {\n    const obj = takeObject(arg0).original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    const ret = false;\n    return ret;\n};\n\nexport function __wbg_randomFillSync_dc1e9a60c158336d() { return handleError(function (arg0, arg1) {\n    getObject(arg0).randomFillSync(takeObject(arg1));\n}, arguments) };\n\nexport function __wbg_getRandomValues_37fa2ca9e4e07fab() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_crypto_c48a774b022d20ac(arg0) {\n    const ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    const ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_process_298734cf255a885d(arg0) {\n    const ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_versions_e2e78e134e3e5d01(arg0) {\n    const ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_1cd7a5d853dbea79(arg0) {\n    const ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    const ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbg_require_8f08ceecec0f4fee() { return handleError(function () {\n    const ret = module.require;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_msCrypto_bcb970640f50a1e8(arg0) {\n    const ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_signal_4bd18fb489af2d4c(arg0) {\n    const ret = getObject(arg0).signal;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_55c9955722952374() { return handleError(function () {\n    const ret = new AbortController();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_abort_654b796176d117aa(arg0) {\n    getObject(arg0).abort();\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbg_new_1eead62f64ca15ce() { return handleError(function () {\n    const ret = new Headers();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_append_fda9e3432e3e88da() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n}, arguments) };\n\nexport function __wbg_fetch_8eaf01857a5bb21f(arg0, arg1) {\n    const ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_instanceof_Response_fc4327dbfcdf5ced(arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof Response;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nexport function __wbg_url_8503de97f69da463(arg0, arg1) {\n    const ret = getObject(arg1).url;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbg_status_ac85a3142a84caa2(arg0) {\n    const ret = getObject(arg0).status;\n    return ret;\n};\n\nexport function __wbg_headers_b70de86b8e989bc0(arg0) {\n    const ret = getObject(arg0).headers;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_arrayBuffer_288fb3538806e85c() { return handleError(function (arg0) {\n    const ret = getObject(arg0).arrayBuffer();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newwithstrandinit_cad5cd6038c7ff5d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_newnoargs_581967eacc0e2604(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_56693dbed0c32988() {\n    const ret = new Map();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_526fc47e980da008(arg0) {\n    const ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_ddb3312ca1c4e32a() { return handleError(function (arg0) {\n    const ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_done_5c1f01fb660d73b5(arg0) {\n    const ret = getObject(arg0).done;\n    return ret;\n};\n\nexport function __wbg_value_1695675138684bd5(arg0) {\n    const ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_iterator_97f0c81209c6c35a() {\n    const ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_get_97b561fb56f034b5() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_cb65541d95d71282() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_b51585de1b234aff() {\n    const ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_1ff1d729e9aae938() { return handleError(function () {\n    const ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_5f4faef6c12b79ec() { return handleError(function () {\n    const ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_1d39714405582d3c() { return handleError(function () {\n    const ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_651f05c6a0944d1c() { return handleError(function () {\n    const ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    const ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_call_01734de55d61e11d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_set_bedc3d02d0f05eb0(arg0, arg1, arg2) {\n    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_43f1b47c28813cbd(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_165(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        const ret = new Promise(cb0);\n        return addHeapObject(ret);\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nexport function __wbg_resolve_53698b95aaf7fcf8(arg0) {\n    const ret = Promise.resolve(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_f7e06ee3c11698eb(arg0, arg1) {\n    const ret = getObject(arg0).then(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_b2267541e2a73865(arg0, arg1, arg2) {\n    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_085ec1f694018c4f(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8125e318e6245eed(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_72e2208bbc0efc61(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_e5d69174d6984cd7(arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_13db269f57aa838d(arg0, arg1, arg2) {\n    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_stringify_e25465938f3f611f() { return handleError(function (arg0) {\n    const ret = JSON.stringify(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_has_c5fcd020291e56b8() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.has(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_092e06b0f9d71865() { return handleError(function (arg0, arg1, arg2) {\n    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper1617(arg0, arg1, arg2) {\n    const ret = makeMutClosure(arg0, arg1, 377, __wbg_adapter_32);\n    return addHeapObject(ret);\n};\n\n"],"names":["__wbg_set_wasm","wasm","val","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getUint8Memory0","byteLength","Uint8Array","memory","buffer","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","isLikeNone","x","cachedInt32Memory0","getInt32Memory0","Int32Array","debugString","type","concat","description","name","isArray","debug","i","builtInMatches","exec","toString","call","className","JSON","stringify","_","Error","message","stack","__wbg_adapter_32","arg0","arg1","arg2","_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcfbc7aedab76e67e","cachedBigInt64Memory0","getBigInt64Memory0","BigInt64Array","cachedBigUint64Memory0","getArrayU64FromWasm0","BigUint64Array","passArray8ToWasm0","getArrayU8FromWasm0","readParquet","parquet_file","retptr","__wbindgen_add_to_stack_pointer","ptr0","__wbindgen_malloc","len0","r0","r1","r2","v2","__wbindgen_free","readParquetFFI","FFIArrowTable","__wrap","readMetadata","FileMetaData","_assertClass","instance","klass","readRowGroup","schema","meta","ArrowSchema","RowGroupMetaData","__wbg_ptr","readMetadataAsync","url","content_length","__wbindgen_realloc","readRowGroupAsync","row_group_meta","arrow_schema","writeParquet","arrow_file","writer_properties","ptr1","WriterProperties","__destroy_into_raw","v3","_writeParquetFFI","arrow_table","handleError","f","args","apply","this","e","__wbindgen_exn_store","Compression","Object","freeze","UNCOMPRESSED","SNAPPY","GZIP","BROTLI","LZ4","ZSTD","LZ4_RAW","Encoding","PLAIN","PLAIN_DICTIONARY","RLE","BIT_PACKED","DELTA_BINARY_PACKED","DELTA_LENGTH_BYTE_ARRAY","DELTA_BYTE_ARRAY","RLE_DICTIONARY","BYTE_STREAM_SPLIT","WriterVersion","V1","V2","create","prototype","free","__wbg_arrowschema_free","copy","arrowschema_copy","ColumnChunkMetaData","__wbg_columnchunkmetadata_free","filePath","columnchunkmetadata_filePath","v1","fileOffset","columnchunkmetadata_fileOffset","pathInSchema","deferred1_0","deferred1_1","columnchunkmetadata_pathInSchema","statistics_exist","columnchunkmetadata_statistics_exist","getStatisticsMinValue","columnchunkmetadata_getStatisticsMinValue","getStatisticsMaxValue","columnchunkmetadata_getStatisticsMaxValue","getStatisticsNullCount","columnchunkmetadata_getStatisticsNullCount","numValues","columnchunkmetadata_numValues","compressedSize","columnchunkmetadata_compressedSize","uncompressedSize","columnchunkmetadata_uncompressedSize","dataPageOffset","columnchunkmetadata_dataPageOffset","hasIndexPage","columnchunkmetadata_hasIndexPage","indexPageOffset","columnchunkmetadata_indexPageOffset","dictionaryPageOffset","columnchunkmetadata_dictionaryPageOffset","numColumnEncodings","columnchunkmetadata_numColumnEncodings","byteRange","columnchunkmetadata_byteRange","FFIArrowArray","__wbg_ffiarrowarray_free","addr","ffiarrowarray_addr","drop","FFIArrowChunk","__wbg_ffiarrowchunk_free","ffiarrowchunk_length","ffiarrowchunk_addr","FFIArrowField","__wbg_ffiarrowfield_free","FFIArrowRecordBatch","__wbg_ffiarrowrecordbatch_free","array_addr","ffiarrowrecordbatch_array_addr","field_addr","FFIArrowSchema","__wbg_ffiarrowschema_free","ffiarrowschema_addr","__wbg_ffiarrowtable_free","numBatches","schemaAddr","ffiarrowtable_schemaAddr","arrayAddr","chunk","ffiarrowtable_arrayAddr","ffiarrowtable_drop","__wbg_filemetadata_free","filemetadata_copy","version","filemetadata_version","numRows","filemetadata_numRows","createdBy","filemetadata_createdBy","numRowGroups","filemetadata_numRowGroups","rowGroup","filemetadata_rowGroup","filemetadata_schema","SchemaDescriptor","keyValueMetadata","filemetadata_keyValueMetadata","arrowSchema","filemetadata_arrowSchema","__wbg_rowgroupmetadata_free","rowgroupmetadata_numRows","numColumns","rowgroupmetadata_numColumns","column","rowgroupmetadata_column","totalByteSize","rowgroupmetadata_totalByteSize","rowgroupmetadata_compressedSize","__wbg_schemadescriptor_free","schemadescriptor_name","schemadescriptor_numColumns","numFields","schemadescriptor_numFields","__wbg_writerproperties_free","WriterPropertiesBuilder","__wbg_writerpropertiesbuilder_free","constructor","writerpropertiesbuilder_new","build","writerpropertiesbuilder_build","setWriterVersion","value","writerpropertiesbuilder_setWriterVersion","setEncoding","writerpropertiesbuilder_setEncoding","setCompression","writerpropertiesbuilder_setCompression","setStatisticsEnabled","writerpropertiesbuilder_setStatisticsEnabled","__wbindgen_object_drop_ref","__wbindgen_error_new","__wbg_filemetadata_new","__wbindgen_string_new","__wbindgen_bigint_from_i64","__wbindgen_number_new","__wbindgen_object_clone_ref","__wbg_fetch_57429b87be3dcc33","fetch","__wbg_set_841ac57cff3d672b","__wbg_String_88810dfeb4021902","String","len1","__wbindgen_cb_drop","original","cnt","a","__wbg_randomFillSync_dc1e9a60c158336d","randomFillSync","arguments","__wbg_getRandomValues_37fa2ca9e4e07fab","getRandomValues","__wbg_crypto_c48a774b022d20ac","crypto","__wbindgen_is_object","__wbg_process_298734cf255a885d","process","__wbg_versions_e2e78e134e3e5d01","versions","__wbg_node_1cd7a5d853dbea79","node","__wbindgen_is_string","__wbg_require_8f08ceecec0f4fee","__wbg_msCrypto_bcb970640f50a1e8","msCrypto","__wbg_signal_4bd18fb489af2d4c","signal","__wbg_new_55c9955722952374","AbortController","__wbg_abort_654b796176d117aa","abort","__wbindgen_string_get","__wbg_new_1eead62f64ca15ce","Headers","__wbg_append_fda9e3432e3e88da","arg3","arg4","append","__wbg_fetch_8eaf01857a5bb21f","__wbg_instanceof_Response_fc4327dbfcdf5ced","result","Response","__wbg_url_8503de97f69da463","__wbg_status_ac85a3142a84caa2","status","__wbg_headers_b70de86b8e989bc0","headers","__wbg_arrayBuffer_288fb3538806e85c","arrayBuffer","__wbg_newwithstrandinit_cad5cd6038c7ff5d","Request","__wbindgen_is_function","__wbg_newnoargs_581967eacc0e2604","Function","__wbg_new_56693dbed0c32988","Map","__wbg_next_526fc47e980da008","next","__wbg_next_ddb3312ca1c4e32a","__wbg_done_5c1f01fb660d73b5","done","__wbg_value_1695675138684bd5","__wbg_iterator_97f0c81209c6c35a","Symbol","iterator","__wbg_get_97b561fb56f034b5","Reflect","get","__wbg_call_cb65541d95d71282","__wbg_new_b51585de1b234aff","__wbg_self_1ff1d729e9aae938","self","__wbg_window_5f4faef6c12b79ec","window","__wbg_globalThis_1d39714405582d3c","globalThis","__wbg_global_651f05c6a0944d1c","global","__wbindgen_is_undefined","__wbg_call_01734de55d61e11d","__wbg_set_bedc3d02d0f05eb0","__wbg_new_43f1b47c28813cbd","state0","b","Promise","cb0","wasm_bindgen__convert__closures__invoke2_mut__h75211a0883f244f7","__wbg_adapter_165","__wbg_resolve_53698b95aaf7fcf8","resolve","__wbg_then_f7e06ee3c11698eb","then","__wbg_then_b2267541e2a73865","__wbg_buffer_085ec1f694018c4f","__wbg_newwithbyteoffsetandlength_6da8e527659b86aa","__wbg_new_8125e318e6245eed","__wbg_set_5cf90238115182c3","__wbg_length_72e2208bbc0efc61","__wbg_newwithlength_e5d69174d6984cd7","__wbg_subarray_13db269f57aa838d","__wbg_stringify_e25465938f3f611f","__wbg_has_c5fcd020291e56b8","has","__wbg_set_092e06b0f9d71865","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_memory","__wbindgen_closure_wrapper1617","dtor","state","real","_len","_key","__wbindgen_export_2","makeMutClosure"],"sourceRoot":""}