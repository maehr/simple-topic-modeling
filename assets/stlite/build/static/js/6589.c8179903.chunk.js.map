{"version":3,"file":"static/js/6589.c8179903.chunk.js","mappings":"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","sources":["../../../node_modules/parquet-wasm/bundler/arrow2.js","../../../node_modules/parquet-wasm/bundler/arrow2_bg.js"],"sourcesContent":["import * as wasm from \"./arrow2_bg.wasm\";\nimport { __wbg_set_wasm } from \"./arrow2_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./arrow2_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_32(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcfbc7aedab76e67e(arg0, arg1, addHeapObject(arg2));\n}\n\nlet cachedBigInt64Memory0 = null;\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nlet cachedBigUint64Memory0 = null;\n\nfunction getBigUint64Memory0() {\n    if (cachedBigUint64Memory0 === null || cachedBigUint64Memory0.byteLength === 0) {\n        cachedBigUint64Memory0 = new BigUint64Array(wasm.memory.buffer);\n    }\n    return cachedBigUint64Memory0;\n}\n\nfunction getArrayU64FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getBigUint64Memory0().subarray(ptr / 8, ptr / 8 + len);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* Read a Parquet file into Arrow data using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* Example:\n*\n* ```js\n* import { tableFromIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readParquet } from \"parquet-wasm/node2\";\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const arrowUint8Array = readParquet(parquetUint8Array);\n* const arrowTable = tableFromIPC(arrowUint8Array);\n* ```\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @returns Uint8Array containing Arrow data in [IPC Stream format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format). To parse this into an Arrow table, pass to `tableFromIPC` in the Arrow JS bindings.\n* @param {Uint8Array} parquet_file\n* @returns {Uint8Array}\n*/\nexport function readParquet(parquet_file) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.readParquet(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Read a Parquet file into Arrow FFI structs using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* This API is less well tested than the \"normal\" `readParquet` API, but should be faster and have\n* **much** less memory overhead (by a factor of 2). If you hit any bugs, please create a\n* reproducible issue at <https://github.com/kylebarron/parquet-wasm/issues/new>.\n*\n* ## Background\n*\n* Under the hood, `parquet-wasm` first decodes a Parquet file into Arrow _in WebAssembly memory_.\n* But then that WebAssembly memory needs to be copied into JavaScript for use by Arrow JS. The\n* \"normal\" read APIs (e.g. `readParquet`) use the [Arrow IPC\n* format](https://arrow.apache.org/docs/python/ipc.html) to get the data back to JavaScript. But\n* this requires another memory copy _inside WebAssembly_ to assemble the various arrays into a\n* single buffer to be copied back to JS.\n*\n* Instead, this API uses Arrow's [C Data\n* Interface](https://arrow.apache.org/docs/format/CDataInterface.html) to be able to copy or view\n* Arrow arrays from within WebAssembly memory without any serialization.\n*\n* I wrote an [interactive blog\n* post](https://observablehq.com/@kylebarron/zero-copy-apache-arrow-with-webassembly) on this\n* approach and the Arrow C Data Interface if you want to read more!\n*\n* ## Caveats\n*\n* This requires you to use [`arrow-js-ffi`](https://github.com/kylebarron/arrow-js-ffi) to parse\n* the Arrow C Data Interface definitions. This library has not yet been tested in production, so\n* it may have bugs!\n*\n* ## Example:\n*\n* ```js\n* import { Table } from \"apache-arrow\";\n* import { parseRecordBatch } from \"arrow-js-ffi\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readParquetFFI, __wasm } from \"parquet-wasm/node2\";\n*\n* // A reference to the WebAssembly memory object. The way to access this is different for each\n* // environment. In Node, use the __wasm export as shown below. In ESM the memory object will\n* // be found on the returned default export.\n* const WASM_MEMORY = __wasm.memory;\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const wasmArrowTable = readParquetFFI(parquetUint8Array);\n*\n* const recordBatches = [];\n* for (let i = 0; i < wasmArrowTable.numBatches(); i++) {\n*   // Note: Unless you know what you're doing, setting `true` below is recommended to _copy_\n*   // table data from WebAssembly into JavaScript memory. This may become the default in the\n*   // future.\n*   const recordBatch = parseRecordBatch(\n*     WASM_MEMORY.buffer,\n*     wasmArrowTable.arrayAddr(i),\n*     wasmArrowTable.schemaAddr(),\n*     true\n*   );\n*   batches.push(recordBatch);\n* }\n*\n* const table = new Table(batches);\n* ```\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @returns an {@linkcode FFIArrowTable} object containing the parsed Arrow table in WebAssembly memory. To read into an Arrow JS table, you'll need to use the Arrow C Data interface.\n* @param {Uint8Array} parquet_file\n* @returns {FFIArrowTable}\n*/\nexport function readParquetFFI(parquet_file) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.readParquetFFI(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return FFIArrowTable.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Read metadata from a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* Example:\n*\n* ```js\n* // Edit the `parquet-wasm` import as necessary\n* import { readMetadata } from \"parquet-wasm/node2\";\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const parquetFileMetaData = readMetadata(parquetUint8Array);\n* ```\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @returns a {@linkcode FileMetaData} object containing metadata of the Parquet file.\n* @param {Uint8Array} parquet_file\n* @returns {FileMetaData}\n*/\nexport function readMetadata(parquet_file) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        wasm.readMetadata(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return FileMetaData.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* Read a single row group from a Parquet file into Arrow data using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* Example:\n*\n* ```js\n* import { tableFromIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readRowGroup, readMetadata } from \"parquet-wasm/node2\";\n*\n* const resp = await fetch(\"https://example.com/file.parquet\");\n* const parquetUint8Array = new Uint8Array(await resp.arrayBuffer());\n* const parquetFileMetaData = readMetadata(parquetUint8Array);\n*\n* // Read only the first row group\n* const arrowIpcBuffer = wasm.readRowGroup(parquetUint8Array, parquetFileMetaData, 0);\n* const arrowTable = tableFromIPC(arrowUint8Array);\n* ```\n*\n* Note that you can get the number of row groups in a Parquet file using {@linkcode FileMetaData.numRowGroups}\n*\n* @param parquet_file Uint8Array containing Parquet data\n* @param meta {@linkcode FileMetaData} from a call to {@linkcode readMetadata}\n* @param i Number index of the row group to parse\n* @returns Uint8Array containing Arrow data in [IPC Stream format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format). To parse this into an Arrow table, pass to `tableFromIPC` in the Arrow JS bindings.\n* @param {Uint8Array} parquet_file\n* @param {ArrowSchema} schema\n* @param {RowGroupMetaData} meta\n* @returns {Uint8Array}\n*/\nexport function readRowGroup(parquet_file, schema, meta) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(schema, ArrowSchema);\n        _assertClass(meta, RowGroupMetaData);\n        wasm.readRowGroup(retptr, ptr0, len0, schema.__wbg_ptr, meta.__wbg_ptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v2 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v2;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Asynchronously read metadata from a Parquet file using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* For now, this requires knowing the content length of the file, but hopefully this will be\n* relaxed in the future.\n*\n* Example:\n*\n* ```js\n* // Edit the `parquet-wasm` import as necessary\n* import { readMetadataAsync } from \"parquet-wasm\";\n*\n* const parquetFileMetaData = await readMetadataAsync(url);\n* ```\n*\n* @param url String location of remote Parquet file containing Parquet data\n* @param content_length Number content length of file in bytes\n* @returns a {@linkcode FileMetaData} object containing metadata of the Parquet file.\n* @param {string} url\n* @param {number | undefined} content_length\n* @returns {Promise<FileMetaData>}\n*/\nexport function readMetadataAsync(url, content_length) {\n    const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.readMetadataAsync(ptr0, len0, !isLikeNone(content_length), isLikeNone(content_length) ? 0 : content_length);\n    return takeObject(ret);\n}\n\n/**\n* Asynchronously read a single row group from a Parquet file into Arrow data using the\n* [`arrow2`](https://crates.io/crates/arrow2) and [`parquet2`](https://crates.io/crates/parquet2)\n* Rust crates.\n*\n* Example:\n*\n* ```js\n* import { tableFromIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { readRowGroupAsync, readMetadataAsync } from \"parquet-wasm\";\n*\n* const url = \"https://example.com/file.parquet\";\n* const headResp = await fetch(url, {method: 'HEAD'});\n* const length = parseInt(headResp.headers.get('Content-Length'));\n*\n* const parquetFileMetaData = await readMetadataAsync(url, length);\n*\n* // Read all batches from the file in parallel\n* const promises = [];\n* for (let i = 0; i < parquetFileMetaData.numRowGroups(); i++) {\n*   // IMPORTANT: For now, calling `copy()` on the metadata object is required whenever passing in to\n*   // a function. Hopefully this can be resolved in the future sometime\n*   const rowGroupPromise = wasm.readRowGroupAsync(url, metadata.copy().rowGroup(i));\n*   promises.push(rowGroupPromise);\n* }\n*\n* const recordBatchChunks = await Promise.all(promises);\n* const table = new arrow.Table(recordBatchChunks);\n* ```\n*\n* Note that you can get the number of row groups in a Parquet file using {@linkcode FileMetaData.numRowGroups}\n*\n* @param url String location of remote Parquet file containing Parquet data\n* @param content_length Number content length of file in bytes\n* @param meta {@linkcode FileMetaData} from a call to {@linkcode readMetadata}\n* @param i Number index of the row group to load\n* @returns Uint8Array containing Arrow data in [IPC Stream format](https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format). To parse this into an Arrow table, pass to `tableFromIPC` in the Arrow JS bindings.\n* @param {string} url\n* @param {RowGroupMetaData} row_group_meta\n* @param {ArrowSchema} arrow_schema\n* @returns {Promise<Uint8Array>}\n*/\nexport function readRowGroupAsync(url, row_group_meta, arrow_schema) {\n    const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    _assertClass(row_group_meta, RowGroupMetaData);\n    _assertClass(arrow_schema, ArrowSchema);\n    const ret = wasm.readRowGroupAsync(ptr0, len0, row_group_meta.__wbg_ptr, arrow_schema.__wbg_ptr);\n    return takeObject(ret);\n}\n\n/**\n* Write Arrow data to a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* For example, to create a Parquet file with Snappy compression:\n*\n* ```js\n* import { tableToIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { WriterPropertiesBuilder, Compression, writeParquet } from \"parquet-wasm/node2\";\n*\n* // Given an existing arrow table under `table`\n* const arrowUint8Array = tableToIPC(table, \"file\");\n* const writerProperties = new WriterPropertiesBuilder()\n*   .setCompression(Compression.SNAPPY)\n*   .build();\n* const parquetUint8Array = writeParquet(arrowUint8Array, writerProperties);\n* ```\n*\n* If `writerProperties` is not provided or is `null`, the default writer properties will be used.\n* This is equivalent to `new WriterPropertiesBuilder().build()`.\n*\n* @param arrow_file Uint8Array containing Arrow data in [IPC **File** format](https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format). If you have an Arrow table in JS, call `tableToIPC(table, \"file\")` in the JS bindings and pass the result here.\n* @param writer_properties Configuration for writing to Parquet. Use the {@linkcode WriterPropertiesBuilder} to build a writing configuration, then call `.build()` to create an immutable writer properties to pass in here.\n* @returns Uint8Array containing written Parquet data.\n* @param {Uint8Array} arrow_file\n* @param {WriterProperties | undefined} writer_properties\n* @returns {Uint8Array}\n*/\nexport function writeParquet(arrow_file, writer_properties) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        const ptr0 = passArray8ToWasm0(arrow_file, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        let ptr1 = 0;\n        if (!isLikeNone(writer_properties)) {\n            _assertClass(writer_properties, WriterProperties);\n            ptr1 = writer_properties.__destroy_into_raw();\n        }\n        wasm.writeParquet(retptr, ptr0, len0, ptr1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v3 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* Write Arrow data to a Parquet file using the [`arrow2`](https://crates.io/crates/arrow2) and\n* [`parquet2`](https://crates.io/crates/parquet2) Rust crates.\n*\n* For example, to create a Parquet file with Snappy compression:\n*\n* ```js\n* import { tableToIPC } from \"apache-arrow\";\n* // Edit the `parquet-wasm` import as necessary\n* import { WriterPropertiesBuilder, Compression, _writeParquetFFI } from \"parquet-wasm/node2\";\n*\n* // Given an existing arrow table under `table`\n* const arrowUint8Array = tableToIPC(table, \"file\");\n* const writerProperties = new WriterPropertiesBuilder()\n*   .setCompression(Compression.SNAPPY)\n*   .build();\n* const parquetUint8Array = writeParquet(arrowUint8Array, writerProperties);\n* ```\n*\n* If `writerProperties` is not provided or is `null`, the default writer properties will be used.\n* This is equivalent to `new WriterPropertiesBuilder().build()`.\n*\n* @param arrow_table {@linkcode FFIArrowTable} Arrow Table in Wasm memory\n* @param writer_properties Configuration for writing to Parquet. Use the {@linkcode WriterPropertiesBuilder} to build a writing configuration, then call `.build()` to create an immutable writer properties to pass in here.\n* @returns Uint8Array containing written Parquet data.\n* @param {FFIArrowTable} arrow_table\n* @param {WriterProperties | undefined} writer_properties\n* @returns {Uint8Array}\n*/\nexport function _writeParquetFFI(arrow_table, writer_properties) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(arrow_table, FFIArrowTable);\n        var ptr0 = arrow_table.__destroy_into_raw();\n        let ptr1 = 0;\n        if (!isLikeNone(writer_properties)) {\n            _assertClass(writer_properties, WriterProperties);\n            ptr1 = writer_properties.__destroy_into_raw();\n        }\n        wasm._writeParquetFFI(retptr, ptr0, ptr1);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        var r3 = getInt32Memory0()[retptr / 4 + 3];\n        if (r3) {\n            throw takeObject(r2);\n        }\n        var v3 = getArrayU8FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 1);\n        return v3;\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_165(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h75211a0883f244f7(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n* Supported compression algorithms.\n*\n* Codecs added in format version X.Y can be read by readers based on X.Y and later.\n* Codec support may vary between readers based on the format version and\n* libraries available at runtime.\n*/\nexport const Compression = Object.freeze({ UNCOMPRESSED:0,\"0\":\"UNCOMPRESSED\",SNAPPY:1,\"1\":\"SNAPPY\",GZIP:2,\"2\":\"GZIP\",BROTLI:3,\"3\":\"BROTLI\",\n/**\n* @deprecated as of Parquet 2.9.0.\n* Switch to LZ4_RAW\n*/\nLZ4:4,\"4\":\"LZ4\",ZSTD:5,\"5\":\"ZSTD\",LZ4_RAW:6,\"6\":\"LZ4_RAW\", });\n/**\n* Encodings supported by Parquet.\n* Not all encodings are valid for all types. These enums are also used to specify the\n* encoding of definition and repetition levels.\n*/\nexport const Encoding = Object.freeze({\n/**\n* Default byte encoding.\n* - BOOLEAN - 1 bit per value, 0 is false; 1 is true.\n* - INT32 - 4 bytes per value, stored as little-endian.\n* - INT64 - 8 bytes per value, stored as little-endian.\n* - FLOAT - 4 bytes per value, stored as little-endian.\n* - DOUBLE - 8 bytes per value, stored as little-endian.\n* - BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.\n* - FIXED_LEN_BYTE_ARRAY - just the bytes are stored.\n*/\nPLAIN:0,\"0\":\"PLAIN\",\n/**\n* **Deprecated** dictionary encoding.\n*\n* The values in the dictionary are encoded using PLAIN encoding.\n* Since it is deprecated, RLE_DICTIONARY encoding is used for a data page, and\n* PLAIN encoding is used for dictionary page.\n*/\nPLAIN_DICTIONARY:1,\"1\":\"PLAIN_DICTIONARY\",\n/**\n* Group packed run length encoding.\n*\n* Usable for definition/repetition levels encoding and boolean values.\n*/\nRLE:2,\"2\":\"RLE\",\n/**\n* Bit packed encoding.\n*\n* This can only be used if the data has a known max width.\n* Usable for definition/repetition levels encoding.\n*/\nBIT_PACKED:3,\"3\":\"BIT_PACKED\",\n/**\n* Delta encoding for integers, either INT32 or INT64.\n*\n* Works best on sorted data.\n*/\nDELTA_BINARY_PACKED:4,\"4\":\"DELTA_BINARY_PACKED\",\n/**\n* Encoding for byte arrays to separate the length values and the data.\n*\n* The lengths are encoded using DELTA_BINARY_PACKED encoding.\n*/\nDELTA_LENGTH_BYTE_ARRAY:5,\"5\":\"DELTA_LENGTH_BYTE_ARRAY\",\n/**\n* Incremental encoding for byte arrays.\n*\n* Prefix lengths are encoded using DELTA_BINARY_PACKED encoding.\n* Suffixes are stored using DELTA_LENGTH_BYTE_ARRAY encoding.\n*/\nDELTA_BYTE_ARRAY:6,\"6\":\"DELTA_BYTE_ARRAY\",\n/**\n* Dictionary encoding.\n*\n* The ids are encoded using the RLE encoding.\n*/\nRLE_DICTIONARY:7,\"7\":\"RLE_DICTIONARY\",\n/**\n* Encoding for floating-point data.\n*\n* K byte-streams are created where K is the size in bytes of the data type.\n* The individual bytes of an FP value are scattered to the corresponding stream and\n* the streams are concatenated.\n* This itself does not reduce the size of the data but can lead to better compression\n* afterwards.\n*/\nBYTE_STREAM_SPLIT:8,\"8\":\"BYTE_STREAM_SPLIT\", });\n/**\n* The Parquet version to use when writing\n*/\nexport const WriterVersion = Object.freeze({ V1:0,\"0\":\"V1\",V2:1,\"1\":\"V2\", });\n/**\n* Arrow Schema representing a Parquet file.\n*/\nexport class ArrowSchema {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ArrowSchema.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_arrowschema_free(ptr);\n    }\n    /**\n    * Clone this struct in wasm memory.\n    * @returns {ArrowSchema}\n    */\n    copy() {\n        const ret = wasm.arrowschema_copy(this.__wbg_ptr);\n        return ArrowSchema.__wrap(ret);\n    }\n}\n/**\n* Metadata for a column chunk.\n*/\nexport class ColumnChunkMetaData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ColumnChunkMetaData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_columnchunkmetadata_free(ptr);\n    }\n    /**\n    * File where the column chunk is stored.\n    *\n    * If not set, assumed to belong to the same file as the metadata.\n    * This path is relative to the current file.\n    * @returns {string | undefined}\n    */\n    filePath() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_filePath(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Byte offset in `file_path()`.\n    * @returns {bigint}\n    */\n    fileOffset() {\n        const ret = wasm.columnchunkmetadata_fileOffset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {string}\n    */\n    pathInSchema() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_pathInSchema(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {boolean}\n    */\n    statistics_exist() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_statistics_exist(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getStatisticsMinValue() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_getStatisticsMinValue(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getStatisticsMaxValue() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_getStatisticsMaxValue(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getStatisticsNullCount() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_getStatisticsNullCount(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Total number of values in this column chunk. Note that this is not necessarily the number\n    * of rows. E.g. the (nested) array `[[1, 2], [3]]` has 2 rows and 3 values.\n    * @returns {bigint}\n    */\n    numValues() {\n        const ret = wasm.columnchunkmetadata_numValues(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns the total compressed data size of this column chunk.\n    * @returns {bigint}\n    */\n    compressedSize() {\n        const ret = wasm.columnchunkmetadata_compressedSize(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns the total uncompressed data size of this column chunk.\n    * @returns {bigint}\n    */\n    uncompressedSize() {\n        const ret = wasm.columnchunkmetadata_uncompressedSize(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns the offset for the column data.\n    * @returns {bigint}\n    */\n    dataPageOffset() {\n        const ret = wasm.columnchunkmetadata_dataPageOffset(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Returns `true` if this column chunk contains a index page, `false` otherwise.\n    * @returns {boolean}\n    */\n    hasIndexPage() {\n        const ret = wasm.columnchunkmetadata_hasIndexPage(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Returns the offset for the index page.\n    * @returns {bigint | undefined}\n    */\n    indexPageOffset() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_indexPageOffset(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getBigInt64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the offset for the dictionary page, if any.\n    * @returns {bigint | undefined}\n    */\n    dictionaryPageOffset() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_dictionaryPageOffset(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getBigInt64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the number of encodings for this column\n    * @returns {number}\n    */\n    numColumnEncodings() {\n        const ret = wasm.columnchunkmetadata_numColumnEncodings(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns the offset and length in bytes of the column chunk within the file\n    * @returns {BigUint64Array}\n    */\n    byteRange() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.columnchunkmetadata_byteRange(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU64FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 8);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Wrapper around an ArrowArray FFI struct in Wasm memory.\n*/\nexport class FFIArrowArray {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowarray_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    addr() {\n        const ret = wasm.ffiarrowarray_addr(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    */\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowarray_free(ptr);\n    }\n    /**\n    */\n    drop() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowarray_free(ptr);\n    }\n}\n/**\n* Wrapper to represent an Arrow Chunk in Wasm memory, e.g. a  collection of FFI ArrowArray\n* structs\n*/\nexport class FFIArrowChunk {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowchunk_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    length() {\n        const ret = wasm.ffiarrowchunk_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    addr(i) {\n        const ret = wasm.ffiarrowchunk_addr(this.__wbg_ptr, i);\n        return ret;\n    }\n}\n/**\n* Wrapper around an ArrowSchema FFI struct in Wasm memory.\n*/\nexport class FFIArrowField {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowfield_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    addr() {\n        const ret = wasm.ffiarrowarray_addr(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n* Wrapper an Arrow RecordBatch stored as FFI in Wasm memory.\n*\n* Refer to {@linkcode readParquetFFI} for instructions on how to use this.\n*/\nexport class FFIArrowRecordBatch {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowrecordbatch_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    array_addr() {\n        const ret = wasm.ffiarrowrecordbatch_array_addr(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    field_addr() {\n        const ret = wasm.ffiarrowarray_addr(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n* Wrapper around a collection of FFI ArrowSchema structs in Wasm memory\n*/\nexport class FFIArrowSchema {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowschema_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    length() {\n        const ret = wasm.ffiarrowchunk_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    addr(i) {\n        const ret = wasm.ffiarrowschema_addr(this.__wbg_ptr, i);\n        return ret;\n    }\n}\n/**\n* Wrapper around an Arrow Table in Wasm memory (a list of FFIArrowRecordBatch objects.)\n*\n* Refer to {@linkcode readParquetFFI} for instructions on how to use this.\n*/\nexport class FFIArrowTable {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FFIArrowTable.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_ffiarrowtable_free(ptr);\n    }\n    /**\n    * Get the total number of record batches in the table\n    * @returns {number}\n    */\n    numBatches() {\n        const ret = wasm.ffiarrowchunk_length(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Get the pointer to one ArrowSchema FFI struct\n    * @returns {number}\n    */\n    schemaAddr() {\n        const ret = wasm.ffiarrowtable_schemaAddr(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Get the pointer to one ArrowArray FFI struct for a given chunk index and column index\n    * @param chunk number The chunk index to use\n    * @returns number pointer to an ArrowArray FFI struct in Wasm memory\n    * @param {number} chunk\n    * @returns {number}\n    */\n    arrayAddr(chunk) {\n        const ret = wasm.ffiarrowtable_arrayAddr(this.__wbg_ptr, chunk);\n        return ret;\n    }\n    /**\n    */\n    drop() {\n        const ptr = this.__destroy_into_raw();\n        wasm.ffiarrowtable_drop(ptr);\n    }\n}\n/**\n* Metadata for a Parquet file.\n*/\nexport class FileMetaData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(FileMetaData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_filemetadata_free(ptr);\n    }\n    /**\n    * Clone this struct in wasm memory.\n    * @returns {FileMetaData}\n    */\n    copy() {\n        const ret = wasm.filemetadata_copy(this.__wbg_ptr);\n        return FileMetaData.__wrap(ret);\n    }\n    /**\n    * Version of this file.\n    * @returns {number}\n    */\n    version() {\n        const ret = wasm.filemetadata_version(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * number of rows in the file.\n    * @returns {number}\n    */\n    numRows() {\n        const ret = wasm.filemetadata_numRows(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * String message for application that wrote this file.\n    * @returns {string | undefined}\n    */\n    createdBy() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.filemetadata_createdBy(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Number of row groups in the file\n    * @returns {number}\n    */\n    numRowGroups() {\n        const ret = wasm.filemetadata_numRowGroups(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a single RowGroupMetaData by index\n    * @param {number} i\n    * @returns {RowGroupMetaData}\n    */\n    rowGroup(i) {\n        const ret = wasm.filemetadata_rowGroup(this.__wbg_ptr, i);\n        return RowGroupMetaData.__wrap(ret);\n    }\n    /**\n    * @returns {SchemaDescriptor}\n    */\n    schema() {\n        const ret = wasm.filemetadata_schema(this.__wbg_ptr);\n        return SchemaDescriptor.__wrap(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    keyValueMetadata() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.filemetadata_keyValueMetadata(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {ArrowSchema}\n    */\n    arrowSchema() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.filemetadata_arrowSchema(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ArrowSchema.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Metadata for a row group.\n*/\nexport class RowGroupMetaData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RowGroupMetaData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rowgroupmetadata_free(ptr);\n    }\n    /**\n    * Number of rows in this row group.\n    * @returns {number}\n    */\n    numRows() {\n        const ret = wasm.rowgroupmetadata_numRows(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Number of columns in this row group.\n    * @returns {number}\n    */\n    numColumns() {\n        const ret = wasm.rowgroupmetadata_numColumns(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Returns a single column chunk metadata by index\n    * @param {number} i\n    * @returns {ColumnChunkMetaData}\n    */\n    column(i) {\n        const ret = wasm.rowgroupmetadata_column(this.__wbg_ptr, i);\n        return ColumnChunkMetaData.__wrap(ret);\n    }\n    /**\n    * Total byte size of all uncompressed column data in this row group.\n    * @returns {number}\n    */\n    totalByteSize() {\n        const ret = wasm.rowgroupmetadata_totalByteSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Total size of all compressed column data in this row group.\n    * @returns {number}\n    */\n    compressedSize() {\n        const ret = wasm.rowgroupmetadata_compressedSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n* A schema descriptor. This encapsulates the top-level schemas for all the columns,\n* as well as all descriptors for all the primitive columns.\n*/\nexport class SchemaDescriptor {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SchemaDescriptor.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_schemadescriptor_free(ptr);\n    }\n    /**\n    * The schemas' name.\n    * @returns {string}\n    */\n    name() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.schemadescriptor_name(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * The number of columns in the schema\n    * @returns {number}\n    */\n    numColumns() {\n        const ret = wasm.schemadescriptor_numColumns(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * The number of fields in the schema\n    * @returns {number}\n    */\n    numFields() {\n        const ret = wasm.schemadescriptor_numFields(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n}\n/**\n* Immutable struct to hold writing configuration for `writeParquet2`.\n*\n* Use {@linkcode WriterPropertiesBuilder} to create a configuration, then call {@linkcode\n* WriterPropertiesBuilder.build} to create an instance of `WriterProperties`.\n*/\nexport class WriterProperties {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WriterProperties.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_writerproperties_free(ptr);\n    }\n}\n/**\n* Builder to create a writing configuration for `writeParquet2`\n*\n* Call {@linkcode build} on the finished builder to create an immputable {@linkcode WriterProperties} to pass to `writeParquet2`\n*/\nexport class WriterPropertiesBuilder {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(WriterPropertiesBuilder.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_writerpropertiesbuilder_free(ptr);\n    }\n    /**\n    * Returns default state of the builder.\n    */\n    constructor() {\n        const ret = wasm.writerpropertiesbuilder_new();\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Finalizes the configuration and returns immutable writer properties struct.\n    * @returns {WriterProperties}\n    */\n    build() {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_build(ptr);\n        return WriterProperties.__wrap(ret);\n    }\n    /**\n    * Sets writer version.\n    * @param {number} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setWriterVersion(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setWriterVersion(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Sets encoding for any column.\n    *\n    * If dictionary is not enabled, this is treated as a primary encoding for all\n    * columns. In case when dictionary is enabled for any column, this value is\n    * considered to be a fallback encoding for that column.\n    *\n    * Panics if user tries to set dictionary encoding here, regardless of dictionary\n    * encoding flag being set.\n    * @param {number} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setEncoding(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setEncoding(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Sets compression codec for any column.\n    * @param {number} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setCompression(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setCompression(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n    /**\n    * Sets flag to enable/disable statistics for any column.\n    * @param {boolean} value\n    * @returns {WriterPropertiesBuilder}\n    */\n    setStatisticsEnabled(value) {\n        const ptr = this.__destroy_into_raw();\n        const ret = wasm.writerpropertiesbuilder_setStatisticsEnabled(ptr, value);\n        return WriterPropertiesBuilder.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_error_new(arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_filemetadata_new(arg0) {\n    const ret = FileMetaData.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_bigint_from_i64(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_object_clone_ref(arg0) {\n    const ret = getObject(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_fetch_57429b87be3dcc33(arg0) {\n    const ret = fetch(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_841ac57cff3d672b(arg0, arg1, arg2) {\n    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n};\n\nexport function __wbg_String_88810dfeb4021902(arg0, arg1) {\n    const ret = String(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbindgen_cb_drop(arg0) {\n    const obj = takeObject(arg0).original;\n    if (obj.cnt-- == 1) {\n        obj.a = 0;\n        return true;\n    }\n    const ret = false;\n    return ret;\n};\n\nexport function __wbg_randomFillSync_dc1e9a60c158336d() { return handleError(function (arg0, arg1) {\n    getObject(arg0).randomFillSync(takeObject(arg1));\n}, arguments) };\n\nexport function __wbg_getRandomValues_37fa2ca9e4e07fab() { return handleError(function (arg0, arg1) {\n    getObject(arg0).getRandomValues(getObject(arg1));\n}, arguments) };\n\nexport function __wbg_crypto_c48a774b022d20ac(arg0) {\n    const ret = getObject(arg0).crypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_object(arg0) {\n    const val = getObject(arg0);\n    const ret = typeof(val) === 'object' && val !== null;\n    return ret;\n};\n\nexport function __wbg_process_298734cf255a885d(arg0) {\n    const ret = getObject(arg0).process;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_versions_e2e78e134e3e5d01(arg0) {\n    const ret = getObject(arg0).versions;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_node_1cd7a5d853dbea79(arg0) {\n    const ret = getObject(arg0).node;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_is_string(arg0) {\n    const ret = typeof(getObject(arg0)) === 'string';\n    return ret;\n};\n\nexport function __wbg_require_8f08ceecec0f4fee() { return handleError(function () {\n    const ret = module.require;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_msCrypto_bcb970640f50a1e8(arg0) {\n    const ret = getObject(arg0).msCrypto;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_signal_4bd18fb489af2d4c(arg0) {\n    const ret = getObject(arg0).signal;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_55c9955722952374() { return handleError(function () {\n    const ret = new AbortController();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_abort_654b796176d117aa(arg0) {\n    getObject(arg0).abort();\n};\n\nexport function __wbindgen_string_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'string' ? obj : undefined;\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbg_new_1eead62f64ca15ce() { return handleError(function () {\n    const ret = new Headers();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_append_fda9e3432e3e88da() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n}, arguments) };\n\nexport function __wbg_fetch_8eaf01857a5bb21f(arg0, arg1) {\n    const ret = getObject(arg0).fetch(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_instanceof_Response_fc4327dbfcdf5ced(arg0) {\n    let result;\n    try {\n        result = getObject(arg0) instanceof Response;\n    } catch {\n        result = false;\n    }\n    const ret = result;\n    return ret;\n};\n\nexport function __wbg_url_8503de97f69da463(arg0, arg1) {\n    const ret = getObject(arg1).url;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbg_status_ac85a3142a84caa2(arg0) {\n    const ret = getObject(arg0).status;\n    return ret;\n};\n\nexport function __wbg_headers_b70de86b8e989bc0(arg0) {\n    const ret = getObject(arg0).headers;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_arrayBuffer_288fb3538806e85c() { return handleError(function (arg0) {\n    const ret = getObject(arg0).arrayBuffer();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_newwithstrandinit_cad5cd6038c7ff5d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_newnoargs_581967eacc0e2604(arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_56693dbed0c32988() {\n    const ret = new Map();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_526fc47e980da008(arg0) {\n    const ret = getObject(arg0).next;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_next_ddb3312ca1c4e32a() { return handleError(function (arg0) {\n    const ret = getObject(arg0).next();\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_done_5c1f01fb660d73b5(arg0) {\n    const ret = getObject(arg0).done;\n    return ret;\n};\n\nexport function __wbg_value_1695675138684bd5(arg0) {\n    const ret = getObject(arg0).value;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_iterator_97f0c81209c6c35a() {\n    const ret = Symbol.iterator;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_get_97b561fb56f034b5() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.get(getObject(arg0), getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_cb65541d95d71282() { return handleError(function (arg0, arg1) {\n    const ret = getObject(arg0).call(getObject(arg1));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_new_b51585de1b234aff() {\n    const ret = new Object();\n    return addHeapObject(ret);\n};\n\nexport function __wbg_self_1ff1d729e9aae938() { return handleError(function () {\n    const ret = self.self;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_window_5f4faef6c12b79ec() { return handleError(function () {\n    const ret = window.window;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_globalThis_1d39714405582d3c() { return handleError(function () {\n    const ret = globalThis.globalThis;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_global_651f05c6a0944d1c() { return handleError(function () {\n    const ret = global.global;\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbindgen_is_undefined(arg0) {\n    const ret = getObject(arg0) === undefined;\n    return ret;\n};\n\nexport function __wbg_call_01734de55d61e11d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_set_bedc3d02d0f05eb0(arg0, arg1, arg2) {\n    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_43f1b47c28813cbd(arg0, arg1) {\n    try {\n        var state0 = {a: arg0, b: arg1};\n        var cb0 = (arg0, arg1) => {\n            const a = state0.a;\n            state0.a = 0;\n            try {\n                return __wbg_adapter_165(a, state0.b, arg0, arg1);\n            } finally {\n                state0.a = a;\n            }\n        };\n        const ret = new Promise(cb0);\n        return addHeapObject(ret);\n    } finally {\n        state0.a = state0.b = 0;\n    }\n};\n\nexport function __wbg_resolve_53698b95aaf7fcf8(arg0) {\n    const ret = Promise.resolve(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_f7e06ee3c11698eb(arg0, arg1) {\n    const ret = getObject(arg0).then(getObject(arg1));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_then_b2267541e2a73865(arg0, arg1, arg2) {\n    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_085ec1f694018c4f(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8125e318e6245eed(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_72e2208bbc0efc61(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_e5d69174d6984cd7(arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_subarray_13db269f57aa838d(arg0, arg1, arg2) {\n    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_stringify_e25465938f3f611f() { return handleError(function (arg0) {\n    const ret = JSON.stringify(getObject(arg0));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_has_c5fcd020291e56b8() { return handleError(function (arg0, arg1) {\n    const ret = Reflect.has(getObject(arg0), getObject(arg1));\n    return ret;\n}, arguments) };\n\nexport function __wbg_set_092e06b0f9d71865() { return handleError(function (arg0, arg1, arg2) {\n    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n    return ret;\n}, arguments) };\n\nexport function __wbindgen_debug_string(arg0, arg1) {\n    const ret = debugString(getObject(arg1));\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len1;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_closure_wrapper1617(arg0, arg1, arg2) {\n    const ret = makeMutClosure(arg0, arg1, 377, __wbg_adapter_32);\n    return addHeapObject(ret);\n};\n\n"],"names":["__wbg_set_wasm","wasm","val","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getUint8Memory0","byteLength","Uint8Array","memory","buffer","getStringFromWasm0","ptr","len","subarray","addHeapObject","obj","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","isLikeNone","x","cachedInt32Memory0","getInt32Memory0","Int32Array","debugString","type","description","name","isArray","debug","i","className","builtInMatches","exec","toString","call","JSON","stringify","_","Error","message","stack","__wbg_adapter_32","arg0","arg1","arg2","_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcfbc7aedab76e67e","cachedBigInt64Memory0","getBigInt64Memory0","BigInt64Array","cachedBigUint64Memory0","getArrayU64FromWasm0","BigUint64Array","passArray8ToWasm0","getArrayU8FromWasm0","readParquet","parquet_file","retptr","__wbindgen_add_to_stack_pointer","ptr0","__wbindgen_malloc","len0","r0","r1","r2","v2","__wbindgen_free","readParquetFFI","FFIArrowTable","__wrap","readMetadata","FileMetaData","_assertClass","instance","klass","readRowGroup","schema","meta","ArrowSchema","RowGroupMetaData","__wbg_ptr","readMetadataAsync","url","content_length","__wbindgen_realloc","readRowGroupAsync","row_group_meta","arrow_schema","writeParquet","arrow_file","writer_properties","ptr1","WriterProperties","__destroy_into_raw","v3","_writeParquetFFI","arrow_table","handleError","f","args","apply","this","e","__wbindgen_exn_store","Compression","Object","freeze","UNCOMPRESSED","SNAPPY","GZIP","BROTLI","LZ4","ZSTD","LZ4_RAW","Encoding","PLAIN","PLAIN_DICTIONARY","RLE","BIT_PACKED","DELTA_BINARY_PACKED","DELTA_LENGTH_BYTE_ARRAY","DELTA_BYTE_ARRAY","RLE_DICTIONARY","BYTE_STREAM_SPLIT","WriterVersion","V1","V2","__wbg_arrowschema_free","arrowschema_copy","create","prototype","ColumnChunkMetaData","__wbg_columnchunkmetadata_free","columnchunkmetadata_filePath","v1","columnchunkmetadata_fileOffset","deferred1_0","deferred1_1","columnchunkmetadata_pathInSchema","columnchunkmetadata_statistics_exist","columnchunkmetadata_getStatisticsMinValue","columnchunkmetadata_getStatisticsMaxValue","columnchunkmetadata_getStatisticsNullCount","columnchunkmetadata_numValues","columnchunkmetadata_compressedSize","columnchunkmetadata_uncompressedSize","columnchunkmetadata_dataPageOffset","columnchunkmetadata_hasIndexPage","columnchunkmetadata_indexPageOffset","columnchunkmetadata_dictionaryPageOffset","columnchunkmetadata_numColumnEncodings","columnchunkmetadata_byteRange","FFIArrowArray","__wbg_ffiarrowarray_free","ffiarrowarray_addr","FFIArrowChunk","__wbg_ffiarrowchunk_free","ffiarrowchunk_length","ffiarrowchunk_addr","FFIArrowField","__wbg_ffiarrowfield_free","FFIArrowRecordBatch","__wbg_ffiarrowrecordbatch_free","ffiarrowrecordbatch_array_addr","FFIArrowSchema","__wbg_ffiarrowschema_free","ffiarrowschema_addr","__wbg_ffiarrowtable_free","ffiarrowtable_schemaAddr","chunk","ffiarrowtable_arrayAddr","ffiarrowtable_drop","__wbg_filemetadata_free","filemetadata_copy","filemetadata_version","filemetadata_numRows","filemetadata_createdBy","filemetadata_numRowGroups","filemetadata_rowGroup","filemetadata_schema","SchemaDescriptor","filemetadata_keyValueMetadata","filemetadata_arrowSchema","__wbg_rowgroupmetadata_free","rowgroupmetadata_numRows","rowgroupmetadata_numColumns","rowgroupmetadata_column","rowgroupmetadata_totalByteSize","rowgroupmetadata_compressedSize","__wbg_schemadescriptor_free","schemadescriptor_name","schemadescriptor_numColumns","schemadescriptor_numFields","__wbg_writerproperties_free","WriterPropertiesBuilder","writerpropertiesbuilder_new","__wbg_writerpropertiesbuilder_free","writerpropertiesbuilder_build","value","writerpropertiesbuilder_setWriterVersion","writerpropertiesbuilder_setEncoding","writerpropertiesbuilder_setCompression","writerpropertiesbuilder_setStatisticsEnabled","__wbindgen_object_drop_ref","__wbindgen_error_new","__wbg_filemetadata_new","__wbindgen_string_new","__wbindgen_bigint_from_i64","__wbindgen_number_new","__wbindgen_object_clone_ref","__wbg_fetch_57429b87be3dcc33","fetch","__wbg_set_841ac57cff3d672b","__wbg_String_88810dfeb4021902","String","len1","__wbindgen_cb_drop","original","cnt","a","__wbg_randomFillSync_dc1e9a60c158336d","randomFillSync","arguments","__wbg_getRandomValues_37fa2ca9e4e07fab","getRandomValues","__wbg_crypto_c48a774b022d20ac","crypto","__wbindgen_is_object","__wbg_process_298734cf255a885d","process","__wbg_versions_e2e78e134e3e5d01","versions","__wbg_node_1cd7a5d853dbea79","node","__wbindgen_is_string","__wbg_require_8f08ceecec0f4fee","__wbg_msCrypto_bcb970640f50a1e8","msCrypto","__wbg_signal_4bd18fb489af2d4c","signal","__wbg_new_55c9955722952374","AbortController","__wbg_abort_654b796176d117aa","abort","__wbindgen_string_get","__wbg_new_1eead62f64ca15ce","Headers","__wbg_append_fda9e3432e3e88da","arg3","arg4","append","__wbg_fetch_8eaf01857a5bb21f","__wbg_instanceof_Response_fc4327dbfcdf5ced","result","Response","__wbg_url_8503de97f69da463","__wbg_status_ac85a3142a84caa2","status","__wbg_headers_b70de86b8e989bc0","headers","__wbg_arrayBuffer_288fb3538806e85c","arrayBuffer","__wbg_newwithstrandinit_cad5cd6038c7ff5d","Request","__wbindgen_is_function","__wbg_newnoargs_581967eacc0e2604","Function","__wbg_new_56693dbed0c32988","Map","__wbg_next_526fc47e980da008","next","__wbg_next_ddb3312ca1c4e32a","__wbg_done_5c1f01fb660d73b5","done","__wbg_value_1695675138684bd5","__wbg_iterator_97f0c81209c6c35a","Symbol","iterator","__wbg_get_97b561fb56f034b5","Reflect","get","__wbg_call_cb65541d95d71282","__wbg_new_b51585de1b234aff","__wbg_self_1ff1d729e9aae938","self","__wbg_window_5f4faef6c12b79ec","window","__wbg_globalThis_1d39714405582d3c","globalThis","__wbg_global_651f05c6a0944d1c","global","__wbindgen_is_undefined","__wbg_call_01734de55d61e11d","__wbg_set_bedc3d02d0f05eb0","__wbg_new_43f1b47c28813cbd","state0","b","Promise","wasm_bindgen__convert__closures__invoke2_mut__h75211a0883f244f7","__wbg_adapter_165","__wbg_resolve_53698b95aaf7fcf8","resolve","__wbg_then_f7e06ee3c11698eb","then","__wbg_then_b2267541e2a73865","__wbg_buffer_085ec1f694018c4f","__wbg_newwithbyteoffsetandlength_6da8e527659b86aa","__wbg_new_8125e318e6245eed","__wbg_set_5cf90238115182c3","__wbg_length_72e2208bbc0efc61","__wbg_newwithlength_e5d69174d6984cd7","__wbg_subarray_13db269f57aa838d","__wbg_stringify_e25465938f3f611f","__wbg_has_c5fcd020291e56b8","has","__wbg_set_092e06b0f9d71865","__wbindgen_debug_string","__wbindgen_throw","__wbindgen_memory","__wbindgen_closure_wrapper1617","dtor","state","real","__wbindgen_export_2","makeMutClosure"],"sourceRoot":""}