{"version":3,"file":"static/js/9655.37b03032.chunk.js","mappings":"kLAIA,MAAM,WAAEA,GAAeC,EAAAA,OAEvB,MAAMC,EAKJC,WAAAA,CAAaC,EAAQC,GACnBC,KAAKF,OAASA,EACdE,KAAKD,UAAYA,CACnB,CAKA,WAAME,CAAOC,GACX,GAAqB,kBAAVA,EACT,GAAmB,UAAfA,EAAMC,KAAkB,CAY1B,GAXIC,OAAOC,UAAUH,EAAMI,WAAaJ,EAAMI,UAAY,IACxDN,KAAKF,OAAOS,KAAKL,EAAMI,UACnBN,KAAKF,OAAOQ,WAAaJ,EAAMI,iBAC3B,IAAIE,SAAQ,CAACC,EAASC,KAC1BV,KAAKF,OAAOa,WAAaF,EACzBT,KAAKF,OAAOc,QAAUF,EACtBV,KAAKF,OAAOe,SAASX,EAAMI,SAAS,IAEtCN,KAAKF,OAAOS,KAAKL,EAAMI,cAGrB,SAAUJ,GACd,MAAM,IAAIY,aAAa,2GAAgH,eAEzIZ,EAAQA,EAAMa,IAChB,KAAO,IAAmB,SAAfb,EAAMC,KAAiB,CAChC,GAAIC,OAAOC,UAAUH,EAAMI,WAAaJ,EAAMI,UAAY,EAAG,CAE3D,GADAN,KAAKF,OAAOS,KAAKL,EAAMI,UACnBN,KAAKF,OAAOQ,WAAaJ,EAAMI,SACjC,MAAM,IAAIQ,aAAa,0BAA2B,qBAEpD,MACF,CACE,MAAM,IAAIA,aAAa,8GAAmH,cAE9I,CAAO,GAAmB,aAAfZ,EAAMC,KACf,OAAO,IAAIK,SAAQC,IACjB,KAAIL,OAAOC,UAAUH,EAAMc,OAASd,EAAMc,MAAQ,GAIhD,MAAM,IAAIF,aAAa,8GAAmH,eAH1Id,KAAKF,OAAOa,WAAaM,GAAOR,IAChCT,KAAKF,OAAOe,SAASX,EAAMc,KAG7B,GAEJ,OAEI,IAAIR,SAAQ,CAACC,EAASC,KAC1BV,KAAKF,OAAOa,WAAaF,EACzBT,KAAKF,OAAOc,QAAUF,EACtBV,KAAKF,OAAOG,MAAM,IAAIiB,KAAK,CAAChB,IAAQ,GAExC,CAEAiB,KAAAA,GACE,OAAO,IAAIX,QAAQR,KAAKD,UAAUqB,KAAKC,KAAKrB,KAAKD,WACnD,EAGK,MAAMuB,EAEXzB,WAAAA,CAAauB,GAAuB,IAAjBG,IAAQC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACzBxB,KAAKoB,KAAOA,EACZpB,KAAK2B,KAAO,OACZ3B,KAAKuB,SAAWA,EAChBvB,KAAK4B,UAAW,CAClB,CAEA,QAAIC,GACF,OAAO7B,KAAKoB,KAAKS,IACnB,CAKAC,WAAAA,CAAaC,GACX,OAAO/B,KAAKoB,KAAKY,UAAYD,EAAMX,KAAKY,OAC1C,CAGAC,OAAAA,GACE,OAAO,IAAIzB,QAAQR,KAAKoB,KAAKA,KAAKC,KAAKrB,KAAKoB,MAC9C,CAGAc,cAAAA,CAAgBC,GACd,IAAKnC,KAAKuB,SAAU,MAAM,IAAIT,gBAAgBpB,GAE9C,OAAO,IAAIc,SAAQ,CAACC,EAASC,IAC3BV,KAAKoB,KAAKgB,cAAaC,KACS,IAA1BF,EAAKG,kBACPD,EAAW1B,WAAaM,GAAOR,EAAQ,IAAIb,EAAKyC,EAAYrC,KAAKoB,OACjEiB,EAAWxB,SAAS,IAEpBJ,EAAQ,IAAIb,EAAKyC,EAAYrC,KAAKoB,MACpC,GACCV,IAEP,EAGK,MAAM6B,EAEX1C,WAAAA,CAAa2C,GAAsB,IAAjBjB,IAAQC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACxBxB,KAAKwC,IAAMA,EACXxC,KAAKuB,SAAWA,EAChBvB,KAAK4B,UAAW,EAChB5B,KAAK2B,KAAO,YACZ3B,KAAK6B,KAAOW,EAAIX,IAClB,CAGAC,WAAAA,CAAaC,GACX,OAAO/B,KAAKwC,IAAIC,WAAaV,EAAMS,IAAIC,QACzC,CAGA,aAAQC,GACN,MAAMC,EAAS3C,KAAKwC,IAAII,eAClBF,QAAgB,IAAIlC,QAAQmC,EAAOE,YAAYxB,KAAKsB,IAC1D,IAAK,MAAMG,KAAKJ,OACR,CAACI,EAAEjB,KAAMiB,EAAEC,OAAS,IAAIzB,EAAWwB,EAAG9C,KAAKuB,UAAY,IAAIgB,EAAaO,EAAG9C,KAAKuB,UAE1F,CAOAyB,kBAAAA,CAAoBnB,EAAMM,GACxB,OAAO,IAAI3B,SAAQ,CAACC,EAASC,KAC3BV,KAAKwC,IAAIS,aAAapB,EAAMM,GAAMK,IAChC/B,EAAQ,IAAI8B,EAAaC,GAAK,GAC7B9B,EAAO,GAEd,CAOAwC,aAAAA,CAAerB,EAAMM,GACnB,OAAO,IAAI3B,SAAQ,CAACC,EAASC,IAC3BV,KAAKwC,IAAIP,QAAQJ,EAAMM,GAAMf,GAAQX,EAAQ,IAAIa,EAAWF,KAAQV,IAExE,CAMA,iBAAMyC,CAAatB,EAAMM,GAEvB,MAAMiB,QAAcpD,KAAKgD,mBAAmBnB,EAAM,CAAEwB,QAAQ,IAASC,OAAMC,GAC5D,sBAAbA,EAAI1B,KAA+B7B,KAAKkD,cAAcrB,EAAM,CAAEwB,QAAQ,IAAWE,IAGnF,GAAIH,aAAiBI,MAAO,MAAMJ,EAElC,OAAO,IAAI5C,SAAQ,CAACC,EAASC,KACvB0C,aAAiBb,EACnBJ,EAAKsB,UACDL,EAAMZ,IAAIkB,mBAAkB,IAAMjD,KAAWC,GAC7C0C,EAAMZ,IAAImB,QAAO,IAAMlD,KAAWC,GAC7B0C,EAAMhC,MACfgC,EAAMhC,KAAKuC,QAAO,IAAMlD,KAAWC,EACrC,GAEJ,EAGF,mBAAe,IAACyB,EAAIX,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAAC,OAAK,IAAIhB,SAAQ,CAACC,EAASC,IAClDkD,OAAOC,wBACL1B,EAAK2B,YAAa,GAClBC,GAAKtD,EAAQ,IAAI8B,EAAawB,EAAEC,QAChCtD,IAEH,C","sources":["../../../node_modules/native-file-system-adapter/src/adapters/sandbox.js"],"sourcesContent":["/* global Blob, DOMException */\n\nimport { errors } from '../util.js'\n\nconst { DISALLOWED } = errors\n\nclass Sink {\n  /**\n   * @param {FileWriter} writer\n   * @param {FileEntry} fileEntry\n   */\n  constructor (writer, fileEntry) {\n    this.writer = writer\n    this.fileEntry = fileEntry\n  }\n\n  /**\n   * @param {BlobPart | Object} chunk\n   */\n  async write (chunk) {\n    if (typeof chunk === 'object') {\n      if (chunk.type === 'write') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            await new Promise((resolve, reject) => {\n              this.writer.onwriteend = resolve\n              this.writer.onerror = reject\n              this.writer.truncate(chunk.position)\n            })\n            this.writer.seek(chunk.position)\n          }\n        }\n        if (!('data' in chunk)) {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. write requires a data argument', 'SyntaxError')\n        }\n        chunk = chunk.data\n      } else if (chunk.type === 'seek') {\n        if (Number.isInteger(chunk.position) && chunk.position >= 0) {\n          this.writer.seek(chunk.position)\n          if (this.writer.position !== chunk.position) {\n            throw new DOMException('seeking position failed', 'InvalidStateError')\n          }\n          return\n        } else {\n          throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. seek requires a position argument', 'SyntaxError')\n        }\n      } else if (chunk.type === 'truncate') {\n        return new Promise(resolve => {\n          if (Number.isInteger(chunk.size) && chunk.size >= 0) {\n            this.writer.onwriteend = evt => resolve()\n            this.writer.truncate(chunk.size)\n          } else {\n            throw new DOMException('Failed to execute \\'write\\' on \\'UnderlyingSinkBase\\': Invalid params passed. truncate requires a size argument', 'SyntaxError')\n          }\n        })\n      }\n    }\n    await new Promise((resolve, reject) => {\n      this.writer.onwriteend = resolve\n      this.writer.onerror = reject\n      this.writer.write(new Blob([chunk]))\n    })\n  }\n\n  close () {\n    return new Promise(this.fileEntry.file.bind(this.fileEntry))\n  }\n}\n\nexport class FileHandle {\n  /** @param {FileEntry} file */\n  constructor (file, writable = true) {\n    this.file = file\n    this.kind = 'file'\n    this.writable = writable\n    this.readable = true\n  }\n\n  get name () {\n    return this.file.name\n  }\n\n  /**\n   * @param {{ file: { toURL: () => string; }; }} other\n   */\n  isSameEntry (other) {\n    return this.file.toURL() === other.file.toURL()\n  }\n\n  /** @return {Promise<File>} */\n  getFile () {\n    return new Promise(this.file.file.bind(this.file))\n  }\n\n  /** @return {Promise<Sink>} */\n  createWritable (opts) {\n    if (!this.writable) throw new DOMException(...DISALLOWED)\n\n    return new Promise((resolve, reject) =>\n      this.file.createWriter(fileWriter => {\n        if (opts.keepExistingData === false) {\n          fileWriter.onwriteend = evt => resolve(new Sink(fileWriter, this.file))\n          fileWriter.truncate(0)\n        } else {\n          resolve(new Sink(fileWriter, this.file))\n        }\n      }, reject)\n    )\n  }\n}\n\nexport class FolderHandle {\n  /** @param {DirectoryEntry} dir */\n  constructor (dir, writable = true) {\n    this.dir = dir\n    this.writable = writable\n    this.readable = true\n    this.kind = 'directory'\n    this.name = dir.name\n  }\n\n  /** @param {FolderHandle} other */\n  isSameEntry (other) {\n    return this.dir.fullPath === other.dir.fullPath\n  }\n\n  /** @returns {AsyncGenerator<[string, FileHandle | FolderHandle]>} */\n  async * entries () {\n    const reader = this.dir.createReader()\n    const entries = await new Promise(reader.readEntries.bind(reader))\n    for (const x of entries) {\n      yield [x.name, x.isFile ? new FileHandle(x, this.writable) : new FolderHandle(x, this.writable)]\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FolderHandle>}\n   */\n  getDirectoryHandle (name, opts) {\n    return new Promise((resolve, reject) => {\n      this.dir.getDirectory(name, opts, dir => {\n        resolve(new FolderHandle(dir))\n      }, reject)\n    })\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ create: boolean; }} opts\n   * @returns {Promise<FileHandle>}\n   */\n  getFileHandle (name, opts) {\n    return new Promise((resolve, reject) =>\n      this.dir.getFile(name, opts, file => resolve(new FileHandle(file)), reject)\n    )\n  }\n\n  /**\n   * @param {string} name\n   * @param {{ recursive: boolean; }} opts\n   */\n  async removeEntry (name, opts) {\n    /** @type {Error|FolderHandle|FileHandle} */\n    const entry = await this.getDirectoryHandle(name, { create: false }).catch(err =>\n      err.name === 'TypeMismatchError' ? this.getFileHandle(name, { create: false }) : err\n    )\n\n    if (entry instanceof Error) throw entry\n\n    return new Promise((resolve, reject) => {\n      if (entry instanceof FolderHandle) {\n        opts.recursive\n          ? entry.dir.removeRecursively(() => resolve(), reject)\n          : entry.dir.remove(() => resolve(), reject)\n      } else if (entry.file) {\n        entry.file.remove(() => resolve(), reject)\n      }\n    })\n  }\n}\n\nexport default (opts = {}) => new Promise((resolve, reject) =>\n  window.webkitRequestFileSystem(\n    opts._persistent, 0,\n    e => resolve(new FolderHandle(e.root)),\n    reject\n  )\n)\n"],"names":["DISALLOWED","errors","Sink","constructor","writer","fileEntry","this","write","chunk","type","Number","isInteger","position","seek","Promise","resolve","reject","onwriteend","onerror","truncate","DOMException","data","size","evt","Blob","close","file","bind","FileHandle","writable","arguments","length","undefined","kind","readable","name","isSameEntry","other","toURL","getFile","createWritable","opts","createWriter","fileWriter","keepExistingData","FolderHandle","dir","fullPath","entries","reader","createReader","readEntries","x","isFile","getDirectoryHandle","getDirectory","getFileHandle","removeEntry","entry","create","catch","err","Error","recursive","removeRecursively","remove","window","webkitRequestFileSystem","_persistent","e","root"],"sourceRoot":""}